<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Grid Community Toolkit: GRAM Job Manager Scheduler Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Grid Community Toolkit
   &#160;<span id="projectnumber">6.2.1541705016</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">GRAM Job Manager Scheduler Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial describes the steps needed to build a GRAM Job Manager Scheduler interface package. The audience for this tutorial is a person interested in adding support for a new scheduler interface to GRAM. This tutorial will assume some familiarty with GTP, autoconf, automake, and Perl. As a reference point, this tutorial will refer to the code in the LSF Job Manager package.</p>
<h1><a class="anchor" id="job_manager_tutorial_service_writing"></a>
Writing a Scheduler Interface</h1>
<p>This section deals with writing the perl module which implements the interface between the GRAM job manager and the local scheduler. Consult the <a class="el" href="globus_gram_job_manager_script_interface.html">Job Manager Scheduler Interface</a> section of this manual for a more detailed reference on the Perl modules which are used here.</p>
<p>The scheduler interface is implemented as a Perl module which is a subclass of the Globus::GRAM::JobManager module. Its name must match the scheduler type string used when the service is installed. For the LSF scheduler, the name is <em>lsf</em>, so the module name is <em>Globus::GRAM::JobManager::lsf</em> and it is stored in the file <code>lsf.pm</code>. Though there are several methods in the JobManager interface, they only ones which absolutely need to be implemented in a scheduler module are submit, poll, cancel.</p>
<p>We'll begin by looking at the start of the lsf source module, lsf.in (the transformation to lsf.pm happens when the setup script is run. To begin the script, we import the GRAM support modules into the scheduler module's namespace, declare the module's namespace, and declare this module as a subclass of the Globus::GRAM::JobManager module. All scheduler packages will need to do this, substituting the name of the scheduler type being implemented where we see <em>lsf</em> below.</p>
<div class="fragment"><div class="line">use Globus::GRAM::Error;</div><div class="line">use Globus::GRAM::JobState;</div><div class="line">use Globus::GRAM::JobManager;</div><div class="line">use Globus::Core::Paths;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">package Globus::GRAM::JobManager::lsf;</div><div class="line"></div><div class="line">@ISA = qw(Globus::GRAM::JobManager);</div></div><!-- fragment --><p>Next, we declare any system-specifc values which will be substituted when the setup package scripts are run. In the LSF case, we need the know the paths to a few programs which interact with the scheduler:</p>
<div class="fragment"><div class="line">my ($mpirun, $bsub, $bjobs, $bkill);</div><div class="line"></div><div class="line">BEGIN</div><div class="line">{</div><div class="line">    $mpirun = <span class="stringliteral">&#39;@MPIRUN@&#39;</span>;</div><div class="line">    $bsub   = <span class="stringliteral">&#39;@BSUB@&#39;</span>;</div><div class="line">    $bjobs  = <span class="stringliteral">&#39;@BJOBS@&#39;</span>;</div><div class="line">    $bkill  = <span class="stringliteral">&#39;@BKILL@&#39;</span>;</div><div class="line">}</div></div><!-- fragment --><p>The values surrounded by the at-sign (such as <code>@MPIRUN@</code>) will be replaced by with the path to the named programs by the <code>find-lsf-tools</code> script described <a class="el" href="globus_gram_job_manager_interface_tutorial.html#system_specific_configuration">below</a>.</p>
<h2><a class="anchor" id="gram_tut_constructor"></a>
Writing a constructor</h2>
<p>For scheduler interfaces which need to setup some data before calling their other methods, they can overload the <code>new</code> method which acts as a constructor. Scheduler scripts which don't need any per-instance initialization will not need to provide a constructor, the Globus::GRAM::JobManager constructor will do the job.</p>
<p>If you do need to overloaded this method, be sure to call the JobManager module's constructor to allow it to do its initialization, as in this example:</p>
<div class="fragment"><div class="line">sub <span class="keyword">new</span></div><div class="line">{</div><div class="line">    my $proto = shift;</div><div class="line">    my $class = ref($proto) || $proto;</div><div class="line">    my $self = $class-&gt;SUPER::new(@_);</div><div class="line"></div><div class="line"><span class="preprocessor">    ## Insert scheduler-specific startup code here</span></div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> $self;</div><div class="line">}</div></div><!-- fragment --><p>The job interface methods are called with only one argument, the scheduler object itself. That object contains the a Globus::GRAM::JobDescription object (<code>$self-&gt;{JobDescription}</code>) which includes the values from the RSL string associated with the request, as well as a few extra values: </p><dl>
<dt>job_id </dt>
<dd>The string returned as the value of JOB_ID in the return hash from submit. This won't be present for methods called before the job is submitted.  </dd>
<dt>uniq_id </dt>
<dd>A string associated with this job request by the job manager program. It will be unique for all jobs on a host for all time.  </dd>
<dt>cache_tag </dt>
<dd>The GASS cache tag related to this job submission. Files in the cache with this tag will be cleaned by the cleanup_cache() method.  </dd>
</dl>
<p>Now, let's look at the methods which will interface to the scheduler.</p>
<h2><a class="anchor" id="gram_tut_submitting_jobs"></a>
Submitting Jobs</h2>
<p>All scheduler modules must implement the submit method. This method is called when the job manager wishes to submit the job to the scheduler. The information in the original job request RSL string is available to the scheduler interface through the <code>JobDescription</code> data member of it's hash.</p>
<p>For most schedulers, this is the longest method to be implemented, as it must decide what to do with the job description, and convert them to something which the scheduler can understand.</p>
<p>We'll look at some of the steps in the LSF manager code to see how the scheduler interface is implemented.</p>
<p>In the beginning of the submit method, we'll get our parameters and look up the job description in the manager-specific object:</p>
<div class="fragment"><div class="line">sub submit</div><div class="line">{</div><div class="line">    my $self = shift;</div><div class="line">    my $description = $self-&gt;{JobDescription};</div></div><!-- fragment --><p>Then we will check for values of the job parameters that we will be handling. For example, this is how we check for a valid job type in the LSF scheduler interface:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>(defined($description-&gt;jobtype())</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span>($description-&gt;jobtype !~ /^(mpi|single|multiple)$/)</div><div class="line">    {</div><div class="line">    <span class="keywordflow">return</span> Globus::GRAM::Error::JOBTYPE_NOT_SUPPORTED;</div><div class="line">    }</div><div class="line">    elsif($description-&gt;jobtype() eq <span class="stringliteral">&#39;mpi&#39;</span> &amp;&amp; $mpirun eq <span class="stringliteral">&quot;no&quot;</span>)</div><div class="line">    {</div><div class="line">    <span class="keywordflow">return</span> Globus::GRAM::Error::JOBTYPE_NOT_SUPPORTED;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The lsf module supports most of the core RSL attributes, so it does more processing to determine what to do with the values in the job description.</p>
<p>Once we've inspected the JobDescription we'll know what we need to tell the scheduler about so that it'll start the job properly. For LSF, we will construct a job description script and pass that to the <code>bsub</code> command. This script is a bourne shell script with some special comments which LSF uses to decide what constraints to use when scheduling the job.</p>
<p>First, we'll open the new file, and write the file header:</p>
<div class="fragment"><div class="line">    $lsf_job_script = <span class="keyword">new</span> IO::File($lsf_job_script_name, <span class="charliteral">&#39;&gt;&#39;</span>);</div><div class="line"></div><div class="line">    $lsf_job_script-&gt;print&lt;&lt;EOF;</div><div class="line"><span class="preprocessor">#! /bin/sh</span></div><div class="line"><span class="preprocessor">#</span></div><div class="line"><span class="preprocessor"># LSF batch job script built by Globus Job Manager</span></div><div class="line"><span class="preprocessor">#</span></div><div class="line"><span class="preprocessor">EOF</span></div></div><!-- fragment --><p>Then, we'll add some special comments to pass job constraints to LSF:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>(defined($queue))</div><div class="line">{</div><div class="line">    $lsf_job_script-&gt;print(<span class="stringliteral">&quot;#BSUB -q $queue\n&quot;</span>);</div><div class="line">}</div><div class="line"><span class="keywordflow">if</span>(defined($description-&gt;project()))</div><div class="line">{</div><div class="line">    $lsf_job_script-&gt;print(<span class="stringliteral">&quot;#BSUB -P &quot;</span> . $description-&gt;project() . <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p>Before we start the executable in the LSF job description script, we will quote and escape the job's arguments so that they will be passed to the application as they were in the job submission RSL string:</p>
<p>At the end of the job description script, we actually run the executable named in the JobDescription. For LSF, we support a few different job types which require different startup commands. Here, we will quote and escape the strings in the argument list so that the values of the arguments will be identical to those in the initial job request string. For this Bourne-shell syntax script, we will double-quote each argument, and escaping the backslash (), dollar-sign ($), double-quote (&quot;), and single-quote (') characters. We will use this new string later in the script.</p>
<div class="fragment"><div class="line">@arguments = $description-&gt;arguments();</div><div class="line"></div><div class="line"><span class="keywordflow">foreach</span>(@arguments)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span>(ref($_))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> Globus::GRAM::Error::RSL_ARGUMENTS;</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keywordflow">if</span>($arguments[0])</div><div class="line">{</div><div class="line">    <span class="keywordflow">foreach</span>(@arguments)</div><div class="line">    {</div><div class="line">         $_ =~ s/\\/\\\\/g;</div><div class="line">         $_ =~ s/\$/\\\$/g;</div><div class="line">         $_ =~ s/<span class="stringliteral">&quot;/\\\&quot;/g;</span></div><div class="line"><span class="stringliteral">         $_ =~ s/`/\\\`/g;</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">         $args .= &#39;&quot;</span><span class="stringliteral">&#39; . $_ . &#39;</span><span class="stringliteral">&quot; &#39;;</span></div><div class="line"><span class="stringliteral">    }</span></div><div class="line"><span class="stringliteral">}</span></div><div class="line"><span class="stringliteral">else</span></div><div class="line"><span class="stringliteral">{</span></div><div class="line"><span class="stringliteral">    $args = &quot;</span><span class="stringliteral">&quot;;</span></div><div class="line"><span class="stringliteral">}</span></div></div><!-- fragment --><p>To end the LSF job description script, we will write the command line of the executable to the script. Depending on the job type of this submission, we will need to start either one or more instances of the executable, or the mpirun program which will start the job with the executable count in the <code>JobDescription</code>:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>($description-&gt;jobtype() eq <span class="stringliteral">&quot;mpi&quot;</span>)</div><div class="line">{</div><div class="line">    $lsf_job_script-&gt;print(<span class="stringliteral">&quot;$mpirun -np &quot;</span> . $description-&gt;count() . <span class="stringliteral">&quot; &quot;</span>);</div><div class="line"></div><div class="line">    $lsf_job_script-&gt;print($description-&gt;executable()</div><div class="line">               . <span class="stringliteral">&quot; $args \n&quot;</span>);</div><div class="line">}</div><div class="line">elsif($description-&gt;jobtype() eq <span class="stringliteral">&#39;multiple&#39;</span>)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span>(my $i = 0; $i &lt; $description-&gt;count(); $i++)</div><div class="line">    {</div><div class="line">    $lsf_job_script-&gt;print($description-&gt;executable() . <span class="stringliteral">&quot; $args &amp;\n&quot;</span>);</div><div class="line">    }</div><div class="line">    $lsf_job_script-&gt;print(<span class="stringliteral">&quot;wait\n&quot;</span>);</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">    $lsf_job_script-&gt;print($description-&gt;executable() . <span class="stringliteral">&quot; $args\n&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p>Next, we submit the job to the scheduler. Be sure to close the script file before trying to redirect it into the submit command, or some of the script file may be buffered and things will fail in strange ways!</p>
<p>When the submission command returns, we check its output for the scheduler-specific job identifier. We will use this value to be able to poll or cancel the job.</p>
<p>The return value of the script should be either a GRAM error object or a reference to a hash of values. The Globus::GRAM::JobManager documentation lists the valid keys to that hash. For the submit method, we'll return the job identifier as the value of JOB_ID in the hash. If the scheduler returned a job status result, we could return that as well. LSF does not, so we'll just check for the job ID and return it, or if the job fails, we'll return an error object:</p>
<div class="fragment"><div class="line">    $lsf_job_script-&gt;close();</div><div class="line"></div><div class="line">    $job_id = (grep(/is submitted/,</div><div class="line">                  split(/\n/, `$bsub &lt; $lsf_job_script_name`)))[0];</div><div class="line">    <span class="keywordflow">if</span>($? == 0)</div><div class="line">    {</div><div class="line">    $job_id =~ m/&lt;([^&gt;]*)&gt;/;</div><div class="line">    $job_id = $1;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> { JOB_ID =&gt; $job_id };</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> Globus::GRAM::Error::INVALID_SCRIPT_REPLY;</div><div class="line">}</div></div><!-- fragment --><p>That finishes the submit method. Most of the functionality for the scheduler interface is now written. We just have a few more (much shorter) methods to implement.</p>
<h2><a class="anchor" id="gram_tut_polling"></a>
Polling Jobs</h2>
<p>All scheduler modules must also implement the poll method. The purpose of this method is to check for updates of a job's status, for example, to see if a job has finished.</p>
<p>When this method is called, we'll get the job ID (which we returned from the submit method above) as well as the original job request information in the object's JobDescription. In the LSF script, we'll pass the job ID to the <code>bjobs</code> program, and that will return the job's status information. We'll compare the status field from the <code>bjobs</code> output to see what job state we should return.</p>
<p>If the job fails, and there is a way to determine that from the scheduler, then the script should return in its hash both </p><div class="fragment"><div class="line">JOB_STATE =&gt; Globus::GRAM::JobState::FAILED</div></div><!-- fragment --><p> and </p><div class="fragment"><div class="line">ERROR =&gt; Globus::GRAM::Error::&lt;ERROR_TYPE&gt;-&gt;value</div></div><!-- fragment --><p>Here's an excerpt from the LSF scheduler module implementation:</p>
<div class="fragment"><div class="line">sub poll</div><div class="line">{</div><div class="line">    my $self = shift;</div><div class="line">    my $description = $self-&gt;{JobDescription};</div><div class="line">    my $job_id = $description-&gt;jobid();</div><div class="line">    my $state;</div><div class="line">    my $status_line;</div><div class="line"></div><div class="line">    $self-&gt;log(<span class="stringliteral">&quot;polling job $job_id&quot;</span>);</div><div class="line"></div><div class="line"><span class="preprocessor">    # Get first line matching job id</span></div><div class="line">    $_ = (grep(/$job_id/, `$bjobs $job_id 2&gt;/dev/null`))[0];</div><div class="line"></div><div class="line"><span class="preprocessor">    # Get 3th field (status)</span></div><div class="line">    $_ = (split(/\s+/))[2];</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(/PEND/)</div><div class="line">    {</div><div class="line">        $state = Globus::GRAM::JobState::PENDING;</div><div class="line">    }</div><div class="line">    elsif(/USUSP|SSUSP|PSUSP/)</div><div class="line">    {</div><div class="line">        $state = Globus::GRAM::JobState::SUSPENDED</div><div class="line">    }</div><div class="line">    ...</div><div class="line">    <span class="keywordflow">return</span> {JOB_STATE =&gt; $state};</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="gram_tut_cancel"></a>
Cancelling Jobs</h2>
<p>All scheduler modules must also implement the cancel method. The purpose of this method is to cancel a running job.</p>
<p>As with the <code>poll</code> method described above, this method will be given the job ID as part of the JobDescription object held by the manager object. If the scheduler interface provides feedback that the job was cancelled successfully, then we can return a JOB_STATE change to the FAILED state. Otherwise we can return an empty hash reference, and let the poll method return the state change next time it is called.</p>
<p>To process a cancel in the LSF case, we will run the bkill command with the job ID.</p>
<div class="fragment"><div class="line">sub cancel</div><div class="line">{</div><div class="line">    my $self = shift;</div><div class="line">    my $description = $self-&gt;{JobDescription};</div><div class="line">    my $job_id = $description-&gt;jobid();</div><div class="line"></div><div class="line">    $self-&gt;log(<span class="stringliteral">&quot;cancel job $job_id&quot;</span>);</div><div class="line"></div><div class="line">    system(<span class="stringliteral">&quot;$bkill $job_id &gt;/dev/null 2&gt;/dev/null&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>($? == 0)</div><div class="line">    {</div><div class="line">    <span class="keywordflow">return</span> { JOB_STATE =&gt; Globus::GRAM::JobState::FAILED }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> Globus::GRAM::Error::JOB_CANCEL_FAILED;</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="gram_tut_exit_1"></a>
End of the script</h2>
<p>It is required that all perl modules return a non-zero value when they are parsed. To do this, make sure the last line of your module consists of:</p>
<div class="fragment"><div class="line">1;</div></div><!-- fragment --><h1><a class="anchor" id="job_manager_tutorial_service_setup"></a>
Setting up a Scheduler</h1>
<p>Once we've written the job manager script, we need to get it installed so that the gatekeeper will be able to run our new service. We do this by writing a setup script. For LSF, we will write the script <code>setup-globus-job-manager-lsf.pl</code>, which we will list in the LSF package as the <b>Post_Install_Program</b>.</p>
<p>To set up the Gatekeeper service, our LSF setup script does the following:</p><ol type="1">
<li>Perform system-specific configuration.</li>
<li>Install the GRAM scheduler Perl module and register as a gatekeeper service.</li>
<li><b>(Optional)</b> Install an RSL validation file defining extra scheduler-specific RSL attributes which the scheduler interface will support.</li>
<li>Update the GPT metadata to indicate that the job manager service has been set up.</li>
</ol>
<h2><a class="anchor" id="system_specific_configuration"></a>
System-Specific Configuration</h2>
<p>First, our scheduler setup script probes for any system-specific information needed to interface with the local scheduler. For example, the LSF scheduler uses the <code>mpirun</code>, <code>bsub</code>, <code>bqueues</code>, <code>bjobs</code>, and <code>bkill</code> commands to submit, poll, and cancel jobs. We'll assume that the administrator who is installing the package has these commands in their path. We'll use an autoconf script to locate the executable paths for these commands and substitute them into our scheduler Perl module. In the LSF package, we have the <code>find-lsf-tools</code> script, which is generated during bootstrap by autoconf from the <code>find-lsf-tools.in</code> file:</p>
<div class="fragment"><div class="line"><span class="preprocessor">## Required Prolog</span></div><div class="line"></div><div class="line">AC_REVISION($Revision$)</div><div class="line">AC_INIT(lsf.in)</div><div class="line"></div><div class="line"><span class="preprocessor"># checking for the GLOBUS_LOCATION</span></div><div class="line"></div><div class="line"><span class="keywordflow">if</span> test <span class="stringliteral">&quot;x$GLOBUS_LOCATION&quot;</span> = <span class="stringliteral">&quot;x&quot;</span>; then</div><div class="line">    echo <span class="stringliteral">&quot;ERROR Please specify GLOBUS_LOCATION&quot;</span> &gt;&amp;2</div><div class="line">    exit 1</div><div class="line">fi</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">## Check <span class="keywordflow">for</span> optional tools, warn <span class="keywordflow">if</span> not found</div><div class="line"></div><div class="line">AC_PATH_PROG(MPIRUN, mpirun, no)</div><div class="line"><span class="keywordflow">if</span> test <span class="stringliteral">&quot;$MPIRUN&quot;</span> = <span class="stringliteral">&quot;no&quot;</span> ; then</div><div class="line">    AC_MSG_WARN([Cannot locate mpirun])</div><div class="line">fi</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">## Check <span class="keywordflow">for</span> required tools, error <span class="keywordflow">if</span> not found</div><div class="line"></div><div class="line">AC_PATH_PROG(BSUB, bsub, no)</div><div class="line"><span class="keywordflow">if</span> test <span class="stringliteral">&quot;$BSUB&quot;</span> = <span class="stringliteral">&quot;no&quot;</span> ; then</div><div class="line">    AC_MSG_ERROR([Cannot locate bsub])</div><div class="line">fi</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">## Required epilog - update scheduler specific module</div><div class="line"></div><div class="line">prefix=<span class="stringliteral">&#39;$(GLOBUS_LOCATION)&#39;</span></div><div class="line">exec_prefix=<span class="stringliteral">&#39;$(GLOBUS_LOCATION)&#39;</span></div><div class="line">libexecdir=${prefix}/libexec</div><div class="line"></div><div class="line">AC_OUTPUT(</div><div class="line">    lsf.pm:lsf.in</div><div class="line">)</div></div><!-- fragment --><p>If this script exits with a non-zero error code, then the setup script propagates the error to the caller and exits without installing the service.</p>
<h2><a class="anchor" id="installing_service_entry"></a>
Registering as a Gatekeeper Service</h2>
<p>Next, the setup script installs it's perl module into the perl library directory and registers an entry in the Globus Gatekeeper's service directory. The program <code><a href="../../perl/globus-job-manager-service.html">globus-job-manager-service</a></code> (distributed in the job manager program setup package) performs both of these tasks. When run, it expects the scheduler perl module to be located in the <code>$GLOBUS_LOCATION/setup/globus</code> directory.</p>
<div class="fragment"><div class="line">$libexecdir/globus-job-manager-service -add -m lsf -s jobmanager-lsf;</div></div><!-- fragment --><h2><a class="anchor" id="installing_validation_file"></a>
Installing an RSL Validation File</h2>
<p>If the scheduler script implements RSL attributes which are not part of the core set supported by the job manager, it must publish them in the job manager's data directory. If the scheduler script wants to set some default values of RSL attributes, it may also set those as the default values in the validation file.</p>
<p>The format of the validation file is described in the <a class="el" href="globus_gram_job_manager_rsl_validation_file.html">RSL Validation File Format</a> section of the documentation. The validation file must be named <em>scheduler-type</em>.rvf and installed in the <code>$GLOBUS_LOCATION/share/globus_gram_job_manager</code> directory.</p>
<p>In the LSF setup script, we check the list of queues supported by the local LSF installation, and add a section of acceptable values for the <em>queue</em> RSL attribute:</p>
<div class="fragment"><div class="line">open(VALIDATION_FILE,</div><div class="line">     <span class="stringliteral">&quot;&gt;$ENV{GLOBUS_LOCATION}/share/globus_gram_job_manager/lsf.rvf&quot;</span>);</div><div class="line"></div><div class="line"><span class="preprocessor"># Customize validation file with queue info</span></div><div class="line">open(BQUEUES, <span class="stringliteral">&quot;bqueues -w |&quot;</span>);</div><div class="line"></div><div class="line"><span class="preprocessor"># discard header</span></div><div class="line">$_ = &lt;BQUEUES&gt;;</div><div class="line">my @queues = ();</div><div class="line"></div><div class="line"><span class="keywordflow">while</span>(&lt;BQUEUES&gt;)</div><div class="line">{</div><div class="line">    chomp;</div><div class="line"></div><div class="line">    $_ =~ m/^(\S+)/;</div><div class="line"></div><div class="line">    push(@queues, $1);</div><div class="line">}</div><div class="line">close(BQUEUES);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span>(@queues)</div><div class="line">{</div><div class="line">    print VALIDATION_FILE <span class="stringliteral">&quot;Attribute: queue\n&quot;</span>;</div><div class="line">    print VALIDATION_FILE join(<span class="stringliteral">&quot; &quot;</span>, <span class="stringliteral">&quot;Values:&quot;</span>, @queues);</div><div class="line"></div><div class="line">}</div><div class="line">close VALIDATION_FILE;</div></div><!-- fragment --><h2><a class="anchor" id="updating_gpt_metadata"></a>
Updating GPT Metadata</h2>
<p>Finally, the setup package should create and finalize a <code>Grid::GPT::Setup</code>. The value of $package must be the same value as the gpt_package_metadata <em>Name</em> attribute in the package's metadata file. If either the <code>new()</code> or <code>finish()</code> methods fail, then it is considered good practice to clean up any files created by the setup script. From <code>setup-globus-job-manager-lsf.pl</code>:</p>
<div class="fragment"><div class="line">my $metadata =</div><div class="line">    <span class="keyword">new</span> Grid::GPT::Setup(</div><div class="line">        package_name =&gt; <span class="stringliteral">&quot;globus_gram_job_manager_setup_lsf&quot;</span>);</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">$metadata-&gt;finish();</div></div><!-- fragment --><h1><a class="anchor" id="job_manager_tutorial_service_packaging"></a>
Packaging</h1>
<p>Now that we've written a job manager scheduler interface, we'll package it using GPT to make it easy for our users to build and install. We'll start by gathering the different files we've written above into a single directory <code>lsf</code>.</p><ul>
<li>lsf.in</li>
<li>find-lsf-tools.in</li>
<li>setup-globus-job-manager.pl</li>
</ul>
<h2><a class="anchor" id="job_manager_tutorial_doc"></a>
Package Documentation</h2>
<p>If there are any scheduler-specific options defined for this scheduler module, or if there any any optional setup items, then it is good to provide a documentation page which describes these. For LSF, we describe the changes since the last version of this package in the file <code>globus_gram_job_manager_lsf.dox</code>. This file consists of a doxygen mainpage. See www.doxygen.org for information on how to write documentation with that tool.</p>
<h2><a class="anchor" id="job_manager_tutorial_configure"></a>
configure.in</h2>
<p>Now, we'll write our configure.in script. This file is converted to the configure shell script by the bootstrap script below. Since we don't do any probes for compile-time tools or system characteristics, we just call the various initialization macros used by GPT, declare that we may provide doxygen documentation, and then output the files we need substitions done on.</p>
<div class="fragment"><div class="line">AC_REVISION($Revision$)</div><div class="line">AC_INIT(Makefile.am)</div><div class="line"></div><div class="line">GLOBUS_INIT</div><div class="line">AM_PROG_LIBTOOL</div><div class="line"></div><div class="line">dnl Initialize the automake rules the last argument</div><div class="line">AM_INIT_AUTOMAKE($GPT_NAME, $GPT_VERSION)</div><div class="line"></div><div class="line">LAC_DOXYGEN(&quot;../&quot;, &quot;*.dox&quot;)</div><div class="line"></div><div class="line">GLOBUS_FINALIZE</div><div class="line"></div><div class="line">AC_OUTPUT(</div><div class="line">        Makefile</div><div class="line">        pkgdata/Makefile</div><div class="line">        pkgdata/pkg_data_src.gpt</div><div class="line">        doxygen/Doxyfile</div><div class="line">        doxygen/Doxyfile-internal</div><div class="line">        doxygen/Makefile</div><div class="line">)</div></div><!-- fragment --><h2><a class="anchor" id="job_manager_tutorial_pkg_data"></a>
Package Metadata</h2>
<p>Now we'll write our metadata file, and put it in the pkgdata subdirectory of our package. The important things to note in this file are the package name and version, the post_install_program, and the setup sections. These define how the package distribution will be named, what command will be run by <code>gpt-postinstall</code> when this package is installed, and what the setup dependencies will be written when the Grid::GPT::Setup object is <a class="el" href="globus_gram_job_manager_interface_tutorial.html#updating_gpt_metadata">finalized</a>.</p>
<div class="fragment"><div class="line">&lt;?xml version=<span class="stringliteral">&quot;1.0&quot;</span> encoding=<span class="stringliteral">&quot;UTF-8&quot;</span>?&gt;</div><div class="line">&lt;!DOCTYPE gpt_package_metadata SYSTEM <span class="stringliteral">&quot;package.dtd&quot;</span>&gt;</div><div class="line"></div><div class="line">&lt;gpt_package_metadata Format_Version=<span class="stringliteral">&quot;0.02&quot;</span> Name=<span class="stringliteral">&quot;globus_gram_job_manager_setup_lsf&quot;</span> &gt;</div><div class="line"></div><div class="line">  &lt;Aging_Version Age=<span class="stringliteral">&quot;0&quot;</span> Major=<span class="stringliteral">&quot;1&quot;</span> Minor=<span class="stringliteral">&quot;0&quot;</span> /&gt;</div><div class="line">  &lt;Description &gt;LSF Job Manager Setup&lt;/Description&gt;</div><div class="line">  &lt;Functional_Group &gt;ResourceManagement&lt;/Functional_Group&gt;</div><div class="line">  &lt;Version_Stability Release=<span class="stringliteral">&quot;Beta&quot;</span> /&gt;</div><div class="line">  &lt;src_pkg &gt;</div><div class="line"></div><div class="line">    &lt;With_Flavors build=<span class="stringliteral">&quot;no&quot;</span> /&gt;</div><div class="line">    &lt;Source_Setup_Dependency PkgType=<span class="stringliteral">&quot;pgm&quot;</span> &gt;</div><div class="line">      &lt;Setup_Dependency Name=<span class="stringliteral">&quot;globus_gram_job_manager_setup&quot;</span> &gt;</div><div class="line">        &lt;Version &gt;</div><div class="line">          &lt;Simple_Version Major=<span class="stringliteral">&quot;3&quot;</span> /&gt;</div><div class="line">        &lt;/Version&gt;</div><div class="line">      &lt;/Setup_Dependency&gt;</div><div class="line">    &lt;/Source_Setup_Dependency&gt;</div><div class="line"></div><div class="line">    &lt;Build_Environment &gt;</div><div class="line">      &lt;cflags &gt;@GPT_CFLAGS@&lt;/cflags&gt;</div><div class="line">      &lt;external_includes &gt;@GPT_EXTERNAL_INCLUDES@&lt;/external_includes&gt;</div><div class="line">      &lt;pkg_libs &gt; &lt;/pkg_libs&gt;</div><div class="line">      &lt;external_libs &gt;@GPT_EXTERNAL_LIBS@&lt;/external_libs&gt;</div><div class="line">    &lt;/Build_Environment&gt;</div><div class="line"></div><div class="line">    &lt;Post_Install_Message &gt;</div><div class="line">      Run the setup-globus-job-manager-lsf setup script to configure an</div><div class="line">      lsf job manager.</div><div class="line">    &lt;/Post_Install_Message&gt;</div><div class="line"></div><div class="line">    &lt;Post_Install_Program &gt;</div><div class="line">      setup-globus-job-manager-lsf</div><div class="line">    &lt;/Post_Install_Program&gt;</div><div class="line"></div><div class="line">    &lt;Setup Name=<span class="stringliteral">&quot;globus_gram_job_manager_service_setup&quot;</span> &gt;</div><div class="line">      &lt;Aging_Version Age=<span class="stringliteral">&quot;0&quot;</span> Major=<span class="stringliteral">&quot;1&quot;</span> Minor=<span class="stringliteral">&quot;0&quot;</span> /&gt;</div><div class="line">    &lt;/Setup&gt;</div><div class="line"></div><div class="line">  &lt;/src_pkg&gt;</div><div class="line"></div><div class="line">&lt;/gpt_package_metadata&gt;</div></div><!-- fragment --><h2><a class="anchor" id="job_manager_tutorial_automake"></a>
Automake Makefile.am</h2>
<p>The automake Makefile.am for this package is short because there isn't any compilation needed for this package. We just need to define what needs to be installed into which directory, and what source files need to be put inot our source distribution. For the LSF package, we need to list the <code>lsf.in</code>, <code>find-lsf-tools</code>, and <code>setup-globus-job-manager-lsf.pl</code> scripts as files to be installed into the setup directory. We need to add those files plus our documentation source file to the EXTRA_LIST variable so that they will be included in source distributions. The rest of the lines in the file are needed for proper interaction with GPT.</p>
<div class="fragment"><div class="line">include $(top_srcdir)/globus_automake_pre</div><div class="line">include $(top_srcdir)/globus_automake_pre_top</div><div class="line"></div><div class="line">SUBDIRS = pkgdata doxygen</div><div class="line"></div><div class="line">setup_SCRIPTS = \</div><div class="line">    lsf.in \
    find-lsf-tools \</div><div class="line">    setup-globus-job-manager-lsf.pl</div><div class="line"></div><div class="line">EXTRA_DIST = $(setup_SCRIPTS) globus_gram_job_manager_lsf.dox</div><div class="line"></div><div class="line">include $(top_srcdir)/globus_automake_post</div><div class="line">include $(top_srcdir)/globus_automake_post_top</div></div><!-- fragment --><h2><a class="anchor" id="job_manager_tutorial_bootstrap"></a>
Bootstrap</h2>
<p>The final piece we need to write for our package is the <code>bootstrap</code> script. This script is the standard bootstrap script for a globus package, with an extra line to generate the <code>fine-lsf-tools</code> script using autoconf.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#!/bin/sh</span></div><div class="line"></div><div class="line"><span class="preprocessor"># checking for the GLOBUS_LOCATION</span></div><div class="line"></div><div class="line"><span class="keywordflow">if</span> test <span class="stringliteral">&quot;x$GLOBUS_LOCATION&quot;</span> = <span class="stringliteral">&quot;x&quot;</span>; then</div><div class="line">    echo <span class="stringliteral">&quot;ERROR Please specify GLOBUS_LOCATION&quot;</span> &gt;&amp;2</div><div class="line">    exit 1</div><div class="line">fi</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> [ ! -f ${GLOBUS_LOCATION}/libexec/globus-bootstrap.sh ]; then</div><div class="line">    echo <span class="stringliteral">&quot;ERROR: Unable to locate \${GLOBUS_LOCATION}/libexec/globus-bootstrap.sh&quot;</span></div><div class="line">    echo <span class="stringliteral">&quot;       Please ensure that you have installed the globus-core package and&quot;</span></div><div class="line">    echo <span class="stringliteral">&quot;       that GLOBUS_LOCATION is set to the proper directory&quot;</span></div><div class="line">    exit</div><div class="line">fi</div><div class="line"></div><div class="line">. ${GLOBUS_LOCATION}/libexec/globus-bootstrap.sh</div><div class="line"></div><div class="line">autoconf find-lsf-tools.in &gt; find-lsf-tools</div><div class="line">chmod 755 find-lsf-tools</div><div class="line"></div><div class="line">exit 0</div></div><!-- fragment --><h1><a class="anchor" id="job_manager_tutorial_building"></a>
Building, Testing, and Debugging</h1>
<p>With this all done, we can now try to build our now package. To do so, we'll need to run</p>
<div class="fragment"><div class="line">% ./bootstrap</div><div class="line">% ./globus-build</div></div><!-- fragment --><p>If all of the files are written correctly, this should result in our package being installed into <code>$GLOBUS_LOCATION</code>. Once that is done, we should be able to run gpt-postinstall to configure our new job manager.</p>
<p>Now, we should be able to run the command</p>
<div class="fragment"><div class="line">% globus-personal-gatekeeper -start -jmtype lsf</div></div><!-- fragment --><p>to start a gatekeeper configured to run a job manager using our new scripts. Running this will output a contact string (referred to as &lt;contact-string&gt; below), which we can use to connect to this new service. To do so, we'll run globus-job-run to submit a test job:</p>
<div class="fragment"><div class="line">% globus-job-run &lt;contact-<span class="keywordtype">string</span>&gt; /bin/echo Hello, LSF</div><div class="line">Hello, LSF</div></div><!-- fragment --><h2><a class="anchor" id="job_manager_tutorial_debugging"></a>
When Things Go Wrong</h2>
<p>If the test above fails, or more complicated job failures are occurring, then you'lll have to debug your scheduler interface. Here are a few tips to help you out.</p>
<p>Make sure that your script is valid Perl. If you run</p>
<div class="fragment"><div class="line">perl -I$GLOBUS_LOCATION/lib/perl \</div><div class="line">    $GLOBUS_LOCATION/lib/perl/Globus/GRAM/JobManager/lsf.pm</div></div><!-- fragment --><p>You should get no output. If there are any diagnostics, correct them (in the lsf.in file), reinstall your package, and rerun the setup script.</p>
<p>Look at the <a href="http://www.globus.org/about/faq/errors.html">Globus Toolkit Error FAQ</a> and see if the failure is perhaps not related to your scheduler script at all.</p>
<p>Enable logging for the job manager. By default, the job manager is configured to log only when it notices a job failure. However, if your problem is that your script is not returning a failure code when you expect, you might want to enable logging always. To do this, modify the job manager configuration file to contain "-save-logfile&amp;nbsp;always" in place of "-save-log&amp;nbsp;on_error".</p>
<p>Adding logging messages to your script: the JobManager object implements a <code>log</code> method, which allows you to write messages to the job manager log file. Do this as your methods are called to pinpoint where the error occurs.</p>
<p>Save the job description file when your script is run. This will allow you to run the <code>globus-job-manager-script.pl</code> interactively (or in the Perl debugger). To save the job description file, you can do</p>
<div class="fragment"><div class="line">$self-&gt;{JobDescription}-&gt;save(<span class="stringliteral">&quot;/tmp/job_description.$$&quot;</span>);</div></div><!-- fragment --><p>in any of the methods you've implemented. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
