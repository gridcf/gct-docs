<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Grid Community Toolkit: Globus XIO Driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Grid Community Toolkit
   &#160;<span id="projectnumber">6.2.1629922860 (tag: v6.2.20210826)</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Globus XIO Driver<div class="ingroups"><a class="el" href="group__globus__xio.html">Globus XIO</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Globus XIO Driver.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__string__globus__xio__driver__programming"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string__globus__xio__driver__programming.html">Driver Programming: String options</a></td></tr>
<tr class="memdesc:group__string__globus__xio__driver__programming"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver Programming: String options. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga3a9838db6dd3455d8cfcd8bbb27668fc"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#ga3a9838db6dd3455d8cfcd8bbb27668fc">globus_xio_driver_callback_t</a> )(globus_xio_operation_t op, <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a> result, void *user_arg)</td></tr>
<tr class="memdesc:ga3a9838db6dd3455d8cfcd8bbb27668fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open and Close Callback Signature.  <a href="#ga3a9838db6dd3455d8cfcd8bbb27668fc">More...</a><br/></td></tr>
<tr class="separator:ga3a9838db6dd3455d8cfcd8bbb27668fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a9093c9edcd0638236f8efc64edd5ab"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#ga2a9093c9edcd0638236f8efc64edd5ab">globus_xio_driver_data_callback_t</a> )(globus_xio_operation_t op, <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a> result, <a class="el" href="group__globus__common.html#gac9ab189b9de1c4adfacd6422598ce60f">globus_size_t</a> nbytes, void *user_arg)</td></tr>
<tr class="separator:ga2a9093c9edcd0638236f8efc64edd5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc11285cedc3e94083b47a930287a709"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#gacc11285cedc3e94083b47a930287a709">globus_xio_driver_attr_init_t</a> )(void **out_driver_attr)</td></tr>
<tr class="separator:gacc11285cedc3e94083b47a930287a709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9a6538e286cb83ed52333d109b2249e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#gae9a6538e286cb83ed52333d109b2249e">globus_xio_driver_attr_copy_t</a> )(void **dst, void *src)</td></tr>
<tr class="separator:gae9a6538e286cb83ed52333d109b2249e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83db49c16a27b7d4ce518c0c87b0850e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#ga83db49c16a27b7d4ce518c0c87b0850e">globus_xio_driver_attr_destroy_t</a> )(void *driver_attr)</td></tr>
<tr class="separator:ga83db49c16a27b7d4ce518c0c87b0850e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada41059a3ff54ab71de3207766dc20f6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#gada41059a3ff54ab71de3207766dc20f6">globus_xio_driver_attr_cntl_t</a> )(void *attr, int cmd, va_list ap)</td></tr>
<tr class="separator:gada41059a3ff54ab71de3207766dc20f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83aab000e4bc988243e7c8757ed756e7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#ga83aab000e4bc988243e7c8757ed756e7">globus_xio_driver_server_init_t</a> )(void *driver_attr, const globus_xio_contact_t *contact_info, globus_xio_operation_t op)</td></tr>
<tr class="separator:ga83aab000e4bc988243e7c8757ed756e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a20203daec4c4f8a2fb03c7dff33c1a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#ga2a20203daec4c4f8a2fb03c7dff33c1a">globus_xio_driver_server_destroy_t</a> )(void *driver_server)</td></tr>
<tr class="separator:ga2a20203daec4c4f8a2fb03c7dff33c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacb8ccac771e03ae6bcb0ebc71a313de"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#gaacb8ccac771e03ae6bcb0ebc71a313de">globus_xio_driver_server_accept_t</a> )(void *driver_server, globus_xio_operation_t op)</td></tr>
<tr class="separator:gaacb8ccac771e03ae6bcb0ebc71a313de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e55e7ed0c9f9c501e1b2600d257870e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#ga8e55e7ed0c9f9c501e1b2600d257870e">globus_xio_driver_server_cntl_t</a> )(void *driver_server, int cmd, va_list ap)</td></tr>
<tr class="separator:ga8e55e7ed0c9f9c501e1b2600d257870e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34a32dfe1e62db38342d8836e49960f7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#ga34a32dfe1e62db38342d8836e49960f7">globus_xio_driver_link_destroy_t</a> )(void *driver_link)</td></tr>
<tr class="separator:ga34a32dfe1e62db38342d8836e49960f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4c0080dfe5cb2cff55ac5e0d0a5a72e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#gaa4c0080dfe5cb2cff55ac5e0d0a5a72e">globus_xio_driver_transform_open_t</a> )(const globus_xio_contact_t *contact_info, void *driver_link, void *driver_attr, globus_xio_operation_t op)</td></tr>
<tr class="memdesc:gaa4c0080dfe5cb2cff55ac5e0d0a5a72e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a handle.  <a href="#gaa4c0080dfe5cb2cff55ac5e0d0a5a72e">More...</a><br/></td></tr>
<tr class="separator:gaa4c0080dfe5cb2cff55ac5e0d0a5a72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabda030c01afbb6307c83056d5bddb2ff"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#gabda030c01afbb6307c83056d5bddb2ff">globus_xio_driver_transport_open_t</a> )(const globus_xio_contact_t *contact_info, void *driver_link, void *driver_attr, globus_xio_operation_t op)</td></tr>
<tr class="memdesc:gabda030c01afbb6307c83056d5bddb2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a handle.  <a href="#gabda030c01afbb6307c83056d5bddb2ff">More...</a><br/></td></tr>
<tr class="separator:gabda030c01afbb6307c83056d5bddb2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf754bfbd5dbe26275881c6231cdafe66"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#gaf754bfbd5dbe26275881c6231cdafe66">globus_xio_driver_handle_cntl_t</a> )(void *handle, int cmd, va_list ap)</td></tr>
<tr class="separator:gaf754bfbd5dbe26275881c6231cdafe66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b49e83be0e47ce74747dfb051f91d22"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#ga2b49e83be0e47ce74747dfb051f91d22">globus_xio_driver_close_t</a> )(void *driver_handle, void *driver_attr, globus_xio_operation_t op)</td></tr>
<tr class="memdesc:ga2b49e83be0e47ce74747dfb051f91d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a handle.  <a href="#ga2b49e83be0e47ce74747dfb051f91d22">More...</a><br/></td></tr>
<tr class="separator:ga2b49e83be0e47ce74747dfb051f91d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef4218084f6dc2a02a1be1d731cd86b5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#gaef4218084f6dc2a02a1be1d731cd86b5">globus_xio_driver_read_t</a> )(void *driver_specific_handle, const globus_xio_iovec_t *iovec, int iovec_count, globus_xio_operation_t op)</td></tr>
<tr class="separator:gaef4218084f6dc2a02a1be1d731cd86b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabca12b784e1b5c28256cedf9d30bc88f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#gabca12b784e1b5c28256cedf9d30bc88f">globus_xio_driver_write_t</a> )(void *driver_specific_handle, const globus_xio_iovec_t *iovec, int iovec_count, globus_xio_operation_t op)</td></tr>
<tr class="separator:gabca12b784e1b5c28256cedf9d30bc88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa0c5bca7682aa876c1a2dde31251f371"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#gaa0c5bca7682aa876c1a2dde31251f371">globus_xio_driver_set_server_pre_init</a> (globus_xio_driver_t driver, <a class="el" href="group__globus__xio__driver.html#ga83aab000e4bc988243e7c8757ed756e7">globus_xio_driver_server_init_t</a> server_pre_init_func)</td></tr>
<tr class="memdesc:gaa0c5bca7682aa876c1a2dde31251f371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Server Pre-Init.  <a href="#gaa0c5bca7682aa876c1a2dde31251f371">More...</a><br/></td></tr>
<tr class="separator:gaa0c5bca7682aa876c1a2dde31251f371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec4f1504f6ee38227189c4aa55ff49ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#gaec4f1504f6ee38227189c4aa55ff49ae">globus_xio_driver_handle_cntl</a> (globus_xio_driver_handle_t handle, globus_xio_driver_t driver, int cmd,...)</td></tr>
<tr class="separator:gaec4f1504f6ee38227189c4aa55ff49ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62c3bbb1d07fcb1cee3bfc1f706a4e5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#ga62c3bbb1d07fcb1cee3bfc1f706a4e5d">globus_xio_driver_finished_accept</a> (globus_xio_operation_t op, void *driver_link, <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a> result)</td></tr>
<tr class="separator:ga62c3bbb1d07fcb1cee3bfc1f706a4e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab05d3c532e2fceb2e901c8158ebed7b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#gab05d3c532e2fceb2e901c8158ebed7b2">globus_xio_driver_pass_open</a> (globus_xio_operation_t op, const globus_xio_contact_t *contact_info, <a class="el" href="group__globus__xio__driver.html#ga3a9838db6dd3455d8cfcd8bbb27668fc">globus_xio_driver_callback_t</a> cb, void *user_arg)</td></tr>
<tr class="separator:gab05d3c532e2fceb2e901c8158ebed7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1147348a3e8c937dd945a81a16f1ea37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#ga1147348a3e8c937dd945a81a16f1ea37">globus_xio_driver_finished_open</a> (void *driver_handle, globus_xio_operation_t op, <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a> result)</td></tr>
<tr class="separator:ga1147348a3e8c937dd945a81a16f1ea37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb6d86a1bcc3e26fa79409fff0c12fbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#gadb6d86a1bcc3e26fa79409fff0c12fbd">globus_xio_driver_operation_create</a> (globus_xio_operation_t *operation, globus_xio_driver_handle_t handle)</td></tr>
<tr class="separator:gadb6d86a1bcc3e26fa79409fff0c12fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a6ca96702627319debc6fb26ef91c3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__globus__common.html#gab407d5994daaaede9d66b8f1361180e2">globus_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#ga7a6ca96702627319debc6fb26ef91c3a">globus_xio_driver_operation_is_blocking</a> (globus_xio_operation_t operation)</td></tr>
<tr class="separator:ga7a6ca96702627319debc6fb26ef91c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1055f3fe75d618ec1b000e6abd0bcf6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#ga1055f3fe75d618ec1b000e6abd0bcf6d">globus_xio_driver_pass_close</a> (globus_xio_operation_t op, <a class="el" href="group__globus__xio__driver.html#ga3a9838db6dd3455d8cfcd8bbb27668fc">globus_xio_driver_callback_t</a> cb, void *callback_arg)</td></tr>
<tr class="memdesc:ga1055f3fe75d618ec1b000e6abd0bcf6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass the close operation down the driver stack.  <a href="#ga1055f3fe75d618ec1b000e6abd0bcf6d">More...</a><br/></td></tr>
<tr class="separator:ga1055f3fe75d618ec1b000e6abd0bcf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17110c23606c39e7019012f1c4ae7d97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#ga17110c23606c39e7019012f1c4ae7d97">globus_xio_driver_finished_close</a> (globus_xio_operation_t op, <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a> result)</td></tr>
<tr class="separator:ga17110c23606c39e7019012f1c4ae7d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58752308dec9897639cbb59a05660ead"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#ga58752308dec9897639cbb59a05660ead">globus_xio_driver_pass_read</a> (globus_xio_operation_t op, globus_xio_iovec_t *iovec, int iovec_count, <a class="el" href="group__globus__common.html#gac9ab189b9de1c4adfacd6422598ce60f">globus_size_t</a> wait_for, <a class="el" href="group__globus__xio__driver.html#ga2a9093c9edcd0638236f8efc64edd5ab">globus_xio_driver_data_callback_t</a> cb, void *user_arg)</td></tr>
<tr class="separator:ga58752308dec9897639cbb59a05660ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga020d50bc13d29b5842136171d86a0c47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#ga020d50bc13d29b5842136171d86a0c47">globus_xio_driver_finished_read</a> (globus_xio_operation_t op, <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a> result, <a class="el" href="group__globus__common.html#gac9ab189b9de1c4adfacd6422598ce60f">globus_size_t</a> nread)</td></tr>
<tr class="separator:ga020d50bc13d29b5842136171d86a0c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e14d54eaea850252b6309167169fbcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#ga2e14d54eaea850252b6309167169fbcb">globus_xio_driver_set_eof_received</a> (globus_xio_operation_t op)</td></tr>
<tr class="separator:ga2e14d54eaea850252b6309167169fbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga709c597e1f6d8bd9b81721d210e59bc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__globus__common.html#gab407d5994daaaede9d66b8f1361180e2">globus_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#ga709c597e1f6d8bd9b81721d210e59bc0">globus_xio_driver_eof_received</a> (globus_xio_operation_t op)</td></tr>
<tr class="separator:ga709c597e1f6d8bd9b81721d210e59bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga188c0c7573ab8ce750931f13c320492c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#ga188c0c7573ab8ce750931f13c320492c">globus_xio_driver_pass_write</a> (globus_xio_operation_t op, globus_xio_iovec_t *iovec, int iovec_count, <a class="el" href="group__globus__common.html#gac9ab189b9de1c4adfacd6422598ce60f">globus_size_t</a> wait_for, <a class="el" href="group__globus__xio__driver.html#ga2a9093c9edcd0638236f8efc64edd5ab">globus_xio_driver_data_callback_t</a> cb, void *user_arg)</td></tr>
<tr class="separator:ga188c0c7573ab8ce750931f13c320492c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb25f01998e61049aa19fc33667b6088"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#gafb25f01998e61049aa19fc33667b6088">globus_xio_driver_finished_write</a> (globus_xio_operation_t op, <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a> result, <a class="el" href="group__globus__common.html#gac9ab189b9de1c4adfacd6422598ce60f">globus_size_t</a> nwritten)</td></tr>
<tr class="separator:gafb25f01998e61049aa19fc33667b6088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga880a528e8cfc2b9551c7b64484fbbc99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__xio__driver.html#ga880a528e8cfc2b9551c7b64484fbbc99">globus_xio_driver_merge_operation</a> (globus_xio_operation_t top_op, globus_xio_operation_t bottom_op)</td></tr>
<tr class="separator:ga880a528e8cfc2b9551c7b64484fbbc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Globus XIO Driver. </p>
<p>Globus XIO introduces a notion of a driver stack to its API. Within globus_xio every I/O operation must occur on a globus_xio handle. Associated with each handle is a stack of drivers. A driver is a modulular piece of code that implements the globus_xio driver interface. The purpose of a driver is manipulate data passed in by the user in someway. Each driver in a stack will serve its own unique purpose.</p>
<p>I/O operations pass from driver to driver, starting at the top of the stack and ending at the bottom. When the bottom layer driver finishes with the operation it signals globus_xio that it has completed. Completion notification then flows up to the top of the driver stack.</p>
<h1><a class="anchor" id="driver_types"></a>
Driver Types</h1>
<dl>
<dt>Transport driver: </dt>
<dd><p class="startdd">A transport driver is one that is responsible for data communication. For example, a TCP or UDP driver would transmit data via network sockets, or a file driver would write data to a file.</p>
<p>There must be exactly one transport driver in a stack, at its bottom. A transport driver never passes an operation to another driver in the stack. Instead, this type of driver relies on globus_xio system functions to implement data operations. </p>
<p class="enddd"></p>
</dd>
<dt>Transform driver: </dt>
<dd><p class="startdd">A transform driver is any intermediate driver in the stack. A transform driver relies on some other drivers on the driver stack to perform the data transport operation. An example of a transform driver would one which implements a network protocol such as http. This driver would frame and parse messages, but would rely on other drivers in the XIO stack.</p>
<p class="enddd">This allows additional transforms to happen in the XIO stack, such as layering the http protocol on top of an SSL protocol driver before transmitting the data via TCP.  </p>
</dd>
</dl>
<h1><a class="anchor" id="driver_api"></a>
Driver API</h1>
<p>The Globus XIO Driver API is a set of functions and interfaces to allow a developer to create an XIO driver. To create a driver the user must implement all of the interface functions in the driver specification. There is also a set of functions provided to assist the driver author in implementing a driver.</p>
<h2><a class="anchor" id="driver_api_quickstart"></a>
Quick Start</h2>
<p>For basic driver needs, the developer will have to pay attention to a few structures and concepts.</p>
<dl>
<dt><code>globus_xio_operation_t</code> </dt>
<dd><p class="startdd">This structure represents a request for an operation. If the driver can service the operation it does so and the calls the appropriate <em>finished</em> function. If the driver cannot completely service the operation it can <em>pass</em> it to the next driver in the stack. As soon as the operation structure is either finished or passed it is no longer valid for use in any other function. </p>
<p class="enddd"></p>
</dd>
<dt><code>globus_xio_driver_handle_t</code> </dt>
<dd>A globus_xio_driver_handle_t represents an open handle to the driver stack for XIO. The driver obtains a driver_handle by calling globus_xio_operation_get_driver_handle(). The driver_handle allows the user to do some complex things that will be described later.  </dd>
</dl>
<h2><a class="anchor" id="globus_xio_driver_typical"></a>
Typical Sequence:</h2>
<p>Here is a typical sequence of events for a globus_xio transform driver. All operations are initiated either by the application calling a function in the Globus XIO API, or from a driver above the transform driver in the stack passing an operation to this driver.</p>
<dl>
<dt>Open </dt>
<dd><p class="startdd">XIO calls the globus_xio_driver_transform_open_t function of the driver, passing it the operation and, in the case of a passive open, the link from a server accept. The driver typically allocates a private data structure containing the state it wishes to associate with this handle, and passes this along with a callback function pointer to <a class="el" href="group__globus__xio__driver.html#gab05d3c532e2fceb2e901c8158ebed7b2">globus_xio_driver_pass_open()</a>. This allows the other drivers in the XIO stack to continue to process the operation.</p>
<p>After the lower drivers in the stack have completed processing the open, they will call <a class="el" href="group__globus__xio__driver.html#ga1147348a3e8c937dd945a81a16f1ea37">globus_xio_driver_finished_open()</a>, which will in turn call the callback function which the driver passed as a parameter to <a class="el" href="group__globus__xio__driver.html#gab05d3c532e2fceb2e901c8158ebed7b2">globus_xio_driver_pass_open()</a>. The driver then does any post-open operation needed, and then finishes the operation by calling <a class="el" href="group__globus__xio__driver.html#ga1147348a3e8c937dd945a81a16f1ea37">globus_xio_driver_finished_open()</a>, passing the private state data as the <em>driver_handle</em> parameter. This state data will be passed to future operation implementations done with this handle.</p>
<p class="enddd"></p>
</dd>
<dt>Read/Write </dt>
<dd><p class="startdd">XIO calls the driver's globus_xio_driver_read_t or globus_xio_driver_write_t function with an operation as a parameter and the state date from the <a class="el" href="group__globus__xio__driver.html#ga1147348a3e8c937dd945a81a16f1ea37">globus_xio_driver_finished_open()</a> call. The driver then transforms the data if necessary and then calls the <a class="el" href="group__globus__xio__driver.html#ga58752308dec9897639cbb59a05660ead">globus_xio_driver_pass_read()</a> or <a class="el" href="group__globus__xio__driver.html#ga188c0c7573ab8ce750931f13c320492c">globus_xio_driver_pass_write()</a> which passes the operation down the XIO driver stack. When the driver below it on the XIO stack calls <a class="el" href="group__globus__xio__driver.html#ga020d50bc13d29b5842136171d86a0c47">globus_xio_driver_finished_read()</a> or <a class="el" href="group__globus__xio__driver.html#gafb25f01998e61049aa19fc33667b6088">globus_xio_driver_finished_write()</a>, the callback which was passed is invoked. In that callback, the driver should itself call <a class="el" href="group__globus__xio__driver.html#ga020d50bc13d29b5842136171d86a0c47">globus_xio_driver_finished_read()</a> or <a class="el" href="group__globus__xio__driver.html#gafb25f01998e61049aa19fc33667b6088">globus_xio_driver_finished_write()</a> to indicate completion. </p>
<p class="enddd"></p>
</dd>
<dt>Close </dt>
<dd>XIO calls the close interface function, passing an operation and the private driver state. The driver will call <a class="el" href="group__globus__xio__driver.html#ga1055f3fe75d618ec1b000e6abd0bcf6d" title="Pass the close operation down the driver stack. ">globus_xio_driver_pass_close()</a> passing it the operation. When the close callback is received the driver calls <a class="el" href="group__globus__xio__driver.html#ga17110c23606c39e7019012f1c4ae7d97">globus_xio_driver_finished_close()</a> passing it the operation. At this point, the driver typically frees its private data, as the handle is no longer valid.  </dd>
</dl>
<h1><a class="anchor" id="globus_xio_driver_attributes"></a>
Globus XIO Attributes</h1>
<p>Attributes provide a way to pass additional metadata to driver operations. Most Globus XIO API functions include an attribute parameter. Each driver implements its own set of attribute handling function. To implement attributes, a driver must provide functions of these types:</p>
<ul>
<li>globus_xio_driver_attr_init_t</li>
<li>globus_xio_driver_attr_copy_t</li>
<li>globus_xio_driver_attr_cntl_t</li>
<li>globus_xio_driver_attr_destroy_t</li>
</ul>
<p>Pointers to these functions are associated with the driver by calling globus_xio_driver_set_attr</p>
<h1><a class="anchor" id="globus_xio_advanced_driver_programming"></a>
Advanced Driver Programming</h1>
<p>The typical driver implementation is describe above. However globus_xio allows driver authors to do more advanced things such as initiating operations on their own.</p>
<dl>
<dt>Read Ahead </dt>
<dd><p class="startdd">Once a handle is open, a driver can create operation structures from it. A driver can then request I/O from the driver stack before it receives a call to its own I/O interface functions, implementing read-ahead functionality. This can be done as follows:</p>
<ol>
<li>
Obtain a driver handle from the open operation by calling globus_xio_operation_get_driver_handle() </li>
<li>
Create an operation by calling <a class="el" href="group__globus__xio__driver.html#gadb6d86a1bcc3e26fa79409fff0c12fbd">globus_xio_driver_operation_create()</a> and pass it the driver_handle from the previous step </li>
<li>
call <a class="el" href="group__globus__xio__driver.html#ga58752308dec9897639cbb59a05660ead">globus_xio_driver_pass_read()</a> using this operation. When the read callback is received, the driver saves the returned data in its private data and then calls <a class="el" href="group__globus__xio__driver.html#ga020d50bc13d29b5842136171d86a0c47">globus_xio_driver_finished_read()</a> on the operation. </li>
<li>
When XIO calls the driver's read interface function, the driver can immediately call <a class="el" href="group__globus__xio__driver.html#ga020d50bc13d29b5842136171d86a0c47">globus_xio_driver_finished_read()</a> function after updating the iovec structure with the data it had previously read. </li>
</ol>
</dd>
</dl>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gada41059a3ff54ab71de3207766dc20f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(* globus_xio_driver_attr_cntl_t)(void *attr, int cmd, va_list ap)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get or set information in an attr.</p>
<p>The cmd parameter determines what functionality the user is requesting. The driver is responsible for providing documentation to the user on all the possible values that cmd can be.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">driver_attr</td><td>The driver specific attr, created by globus_xio_driver_attr_init_t.</td></tr>
    <tr><td class="paramname">cmd</td><td>An integer representing what functionality the user is requesting.</td></tr>
    <tr><td class="paramname">ap</td><td>variable arguments. These are determined by the driver and the value of cmd. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae9a6538e286cb83ed52333d109b2249e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(* globus_xio_driver_attr_copy_t)(void **dst, void *src)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy a driver attr.</p>
<p>When this function is called the driver will create a copy of the attr in parameter src and place it in the parameter dst. </p>

</div>
</div>
<a class="anchor" id="ga83db49c16a27b7d4ce518c0c87b0850e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(* globus_xio_driver_attr_destroy_t)(void *driver_attr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy the driver attr.</p>
<p>Clean up all resources associate with the attr. </p>

</div>
</div>
<a class="anchor" id="gacc11285cedc3e94083b47a930287a709"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(* globus_xio_driver_attr_init_t)(void **out_driver_attr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a driver specific attribute.</p>
<p>The driver should implement this function to create a driver specific attribute and return it via the out_attr parameter. </p>

</div>
</div>
<a class="anchor" id="ga3a9838db6dd3455d8cfcd8bbb27668fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* globus_xio_driver_callback_t)(globus_xio_operation_t op, <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a> result, void *user_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open and Close Callback Signature. </p>
<p>This is the function signature of callbacks for the globus_xio_pass_open() and globus_xio_pass_close() functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation structure associated with the open or the close requested operation. The driver should call the appropriate finished operation to clean up this structure. </td></tr>
    <tr><td class="paramname">result</td><td>The result of the requested data operation </td></tr>
    <tr><td class="paramname">user_arg</td><td>The user pointer that is threaded through to the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2b49e83be0e47ce74747dfb051f91d22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(* globus_xio_driver_close_t)(void *driver_handle, void *driver_attr, globus_xio_operation_t op)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a handle. </p>
<p>This closes a handle. Driver implementations should pass the close to the other drivers in the stack by calling globus_xio_pass_close().</p>
<p>In the close callback, the driver should clean up the data associated with driver_handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">driver_specific_handle</td><td>The driver handle to be closed. </td></tr>
    <tr><td class="paramname">driver_attr</td><td>A driver specific attr which may be used to alter how a close is performed (e.g. caching drivers) </td></tr>
    <tr><td class="paramname">op</td><td>The open operation. When the driver is finished opening the handle, it passes this to <a class="el" href="group__globus__xio__driver.html#ga17110c23606c39e7019012f1c4ae7d97">globus_xio_driver_finished_close()</a> to return status up the driver stack to the application. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2a9093c9edcd0638236f8efc64edd5ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* globus_xio_driver_data_callback_t)(globus_xio_operation_t op, <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a> result, <a class="el" href="group__globus__common.html#gac9ab189b9de1c4adfacd6422598ce60f">globus_size_t</a> nbytes, void *user_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data Callback interface</p>
<p>This is the function signature of read and write operation callbacks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation structure associated with the read or write operation request. The driver should call the appropriate finished operation when it receives this operation.</td></tr>
    <tr><td class="paramname">result</td><td>The result of the requested data operation</td></tr>
    <tr><td class="paramname">nbytes</td><td>the number of bytes read or written</td></tr>
    <tr><td class="paramname">user_arg</td><td>The user pointer that is threaded through to the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf754bfbd5dbe26275881c6231cdafe66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(* globus_xio_driver_handle_cntl_t)(void *handle, int cmd, va_list ap)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this call <em>must</em> return an GLOBUS_XIO_ERROR_COMMAND error for unsupported command numbers. (use GlobusXIOErrorInvalidCommand(cmd))</p>
<p>Drivers that have reason to support the commands listed at <a class="el" href="group__GLOBUS__XIO__API.html#gae526430d0ff439e6a3de3b9f57dfadbc">globus_xio_handle_cmd_t</a> should accept the xio generic cmd numbers and their driver specific command number. Do NOT implement those handle cntls unless you really are the definitive source. </p>

</div>
</div>
<a class="anchor" id="ga34a32dfe1e62db38342d8836e49960f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(* globus_xio_driver_link_destroy_t)(void *driver_link)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>destroy a link</p>
<p>The driver should clean up all resources associated with the link when this function is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">driver_link</td><td>The link to be destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaef4218084f6dc2a02a1be1d731cd86b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(* globus_xio_driver_read_t)(void *driver_specific_handle, const globus_xio_iovec_t *iovec, int iovec_count, globus_xio_operation_t op)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data from an open handle.</p>
<p>This function is called when the user requests to read data from a handle. The driver author shall implement all code needed to for there driver to complete a read operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">driver_handle</td><td>The driver handle from which data should be read.</td></tr>
    <tr><td class="paramname">iovec</td><td>An io vector pointing to the buffers to be read into.</td></tr>
    <tr><td class="paramname">iovec_count</td><td>The number if entries in the io vector.</td></tr>
    <tr><td class="paramname">op</td><td>The requested operation. When the driver is finished fulfilling the requested read operation it must use this structure to signal globus_xio that the operation is completed. This is done by calling globus_xio_driver_finished_operation(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaacb8ccac771e03ae6bcb0ebc71a313de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(* globus_xio_driver_server_accept_t)(void *driver_server, globus_xio_operation_t op)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Accept a server connection</p>
<p>The driver developer should implement this function if their driver handles server operations. Once the accept operation completes, the connection is established. The user still has an opportunity to open the link or destroy it. They can query the link for additional information on which to base the decision to open.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">driver_server</td><td>The server object from which the link connection will be accepted.</td></tr>
    <tr><td class="paramname">op</td><td>The requested operation. When the driver is finished accepting the server connection it uses this structure to signal globus_xio that it has completed the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8e55e7ed0c9f9c501e1b2600d257870e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(* globus_xio_driver_server_cntl_t)(void *driver_server, int cmd, va_list ap)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query a server for information.</p>
<p>This function allows a user to request information from a driver specific server handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">driver_server</td><td>the server handle.</td></tr>
    <tr><td class="paramname">cmd</td><td>An integer telling the driver what operation to preform on this server handle.</td></tr>
    <tr><td class="paramname">ap</td><td>variable args. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2a20203daec4c4f8a2fb03c7dff33c1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(* globus_xio_driver_server_destroy_t)(void *driver_server)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>destroy a server.</p>
<p>When this function is called the driver should free up all resources associated with a server.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">server</td><td>The server that the driver should clean up.</td></tr>
    <tr><td class="paramname">driver_server</td><td>The reference to the internal server that is being declared invalid with this function call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga83aab000e4bc988243e7c8757ed756e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(* globus_xio_driver_server_init_t)(void *driver_attr, const globus_xio_contact_t *contact_info, globus_xio_operation_t op)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a server object</p>
<p>The driver developer should implement this function if their driver handles server operations (passive opens). In the TCP driver this function creates a TCP socket and calls listen() on it. Unlike all other XIO driver implementation functions, the <a class="el" href="group__GLOBUS__XIO__API.html#ga0492f88d94b383e509ef7d47dd57f04c">globus_xio_server_create()</a> function begins at the bottom (transport driver) of the stack, and the globus_xio_driver_pass_server_init() acts like a finished() operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">driver_attr</td><td>A driver-specific attribute. This may be NULL. </td></tr>
    <tr><td class="paramname">contact_info</td><td>Contact information from the stack below this driver. This is NULL for the transport driver. </td></tr>
    <tr><td class="paramname">op</td><td>An op which must be passed to globus_xio_driver_pass_server_init() to pass the server contact information up the XIO driver stack.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returning GLOBUS_SUCCESS for this means that globus_xio_driver_pass_server_init returned success and the driver's server-specific data is initialized. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa4c0080dfe5cb2cff55ac5e0d0a5a72e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(* globus_xio_driver_transform_open_t)(const globus_xio_contact_t *contact_info, void *driver_link, void *driver_attr, globus_xio_operation_t op)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a handle. </p>
<p>This is called when a user opens a handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contact_info</td><td>Contains information about the requested resource. Its members may all be null (especially when link is not null). XIO will destroy this contact info upon return from the interface function</td></tr>
    <tr><td class="paramname">driver_link</td><td>Comes from server accept. Used to link an accepted connection to an xio handle. XIO will destroy this object upon the return of this interface call.</td></tr>
    <tr><td class="paramname">driver_attr</td><td>A attribute describing how to open. This points to a piece of memory created by the globus_xio_driver_attr_init_t interface function.</td></tr>
    <tr><td class="paramname">op</td><td>The open operation. When the driver is finished opening the handle, it passes this to <a class="el" href="group__globus__xio__driver.html#ga1147348a3e8c937dd945a81a16f1ea37">globus_xio_driver_finished_open()</a> to return status up the driver stack to the application. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabda030c01afbb6307c83056d5bddb2ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(* globus_xio_driver_transport_open_t)(const globus_xio_contact_t *contact_info, void *driver_link, void *driver_attr, globus_xio_operation_t op)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a handle. </p>
<p>This is called when a user opens a handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contact_info</td><td>Contains information about the requested resource. Its members may all be null (especially when link is not null). XIO will destroy this contact info upon return from the interface function</td></tr>
    <tr><td class="paramname">driver_link</td><td>Comes from server accept. Used to link an accepted connection to an xio handle. XIO will destroy this object upon the return of this interface call.</td></tr>
    <tr><td class="paramname">driver_attr</td><td>A attribute describing how to open. This points to a piece of memory created by the globus_xio_driver_attr_init_t interface function.</td></tr>
    <tr><td class="paramname">op</td><td>The open operation. When the driver is finished opening the handle, it passes this to <a class="el" href="group__globus__xio__driver.html#ga1147348a3e8c937dd945a81a16f1ea37">globus_xio_driver_finished_open()</a> to return status up the driver stack to the application. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabca12b784e1b5c28256cedf9d30bc88f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>(* globus_xio_driver_write_t)(void *driver_specific_handle, const globus_xio_iovec_t *iovec, int iovec_count, globus_xio_operation_t op)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write data from an open handle.</p>
<p>This function is called when the user requests to write data to a handle. The driver author shall implement all code needed to for there driver to complete write operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">driver_handle</td><td>The driver handle to which data should be written.</td></tr>
    <tr><td class="paramname">iovec</td><td>An io vector pointing to the buffers to be written.</td></tr>
    <tr><td class="paramname">iovec_count</td><td>The number if entries in the io vector.</td></tr>
    <tr><td class="paramname">op</td><td>The requested operation. When the driver is finished fulfilling the requested read operation it must use this structure to signal globus_xio that the operation is completed. This is done by calling globus_xio_driver_finished_operation(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga709c597e1f6d8bd9b81721d210e59bc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__globus__common.html#gab407d5994daaaede9d66b8f1361180e2">globus_bool_t</a> globus_xio_driver_eof_received </td>
          <td>(</td>
          <td class="paramtype">globus_xio_operation_t&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>EOF state checking</p>
<p>This function is used by drivers that allow multiple outstanding reads at a time. It can only be called on behalf of a read operation (while in the read interface call or the pass_read callback).</p>
<p>Typical use for this would be to hold a driver specific lock (the same one used when calling <a class="el" href="group__globus__xio__driver.html#ga2e14d54eaea850252b6309167169fbcb">globus_xio_driver_set_eof_received()</a>) and call this to see if an EOF has been received. If so, the operation should immediately be finished with an EOF error (do not <em>return</em> an EOF error).</p>
<p>This call will typically only be used in the read interface call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation structure representing the requested read operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GLOBUS_TRUE if EOF received, GLOBUS_FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga62c3bbb1d07fcb1cee3bfc1f706a4e5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void globus_xio_driver_finished_accept </td>
          <td>(</td>
          <td class="paramtype">globus_xio_operation_t&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>driver_link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Driver API finished accept</p>
<p>This function should be called to signal globus_xio that it has completed the accept operation requested of it. It will free up resources associated with the accept_op and potentially cause xio to pop the signal up the driver stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The requested accept operation that has completed.</td></tr>
    <tr><td class="paramname">driver_link</td><td>This is the initialized driver link that is that will be passed to the open interface when this handle is opened.</td></tr>
    <tr><td class="paramname">result</td><td>Return status of the completed operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga17110c23606c39e7019012f1c4ae7d97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void globus_xio_driver_finished_close </td>
          <td>(</td>
          <td class="paramtype">globus_xio_operation_t&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Driver API finished_close</p>
<p>The driver calls this function after completing a close operation on a driver_handle. Once this function returns the driver_handle is no longer valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The close operation that has completed.</td></tr>
    <tr><td class="paramname">result</td><td>Return status of the completed operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1147348a3e8c937dd945a81a16f1ea37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void globus_xio_driver_finished_open </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>driver_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">globus_xio_operation_t&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Driver API finished open</p>
<p>This function should be called to signal globus_xio that it has completed the open operation requested of it. It will free up resources associated with the op and potentially cause xio to pop the signal up the driver stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">driver_handle</td><td>The driver specific handle pointer that will be passed to future interface function calls.</td></tr>
    <tr><td class="paramname">op</td><td>The requested open operation that has completed.</td></tr>
    <tr><td class="paramname">result</td><td>Return status of the completed operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga020d50bc13d29b5842136171d86a0c47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void globus_xio_driver_finished_read </td>
          <td>(</td>
          <td class="paramtype">globus_xio_operation_t&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__globus__common.html#gac9ab189b9de1c4adfacd6422598ce60f">globus_size_t</a>&#160;</td>
          <td class="paramname"><em>nread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finished Read</p>
<p>This function is called to signal globus_xio that the requested read operation has been completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation structure representing the requested read operation.</td></tr>
    <tr><td class="paramname">result</td><td>Return status of the completed operation</td></tr>
    <tr><td class="paramname">nread</td><td>The number of bytes read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafb25f01998e61049aa19fc33667b6088"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void globus_xio_driver_finished_write </td>
          <td>(</td>
          <td class="paramtype">globus_xio_operation_t&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a>&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__globus__common.html#gac9ab189b9de1c4adfacd6422598ce60f">globus_size_t</a>&#160;</td>
          <td class="paramname"><em>nwritten</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finished Write</p>
<p>This function is called to signal globus_xio that the requested write operation has been completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation structure representing the requested write operation.</td></tr>
    <tr><td class="paramname">result</td><td>Return status of the completed operation</td></tr>
    <tr><td class="paramname">nwritten</td><td>The number of bytes written </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaec4f1504f6ee38227189c4aa55ff49ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a> globus_xio_driver_handle_cntl </td>
          <td>(</td>
          <td class="paramtype">globus_xio_driver_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">globus_xio_driver_t&#160;</td>
          <td class="paramname"><em>driver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Touch driver specific information in a handle object.</p>
<p>pass the driver to control a specific driver pass NULL for driver for XIO specific cntls pass GLOBUS_XIO_QUERY for driver to try each driver (below current) in order </p>

</div>
</div>
<a class="anchor" id="ga880a528e8cfc2b9551c7b64484fbbc99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a> globus_xio_driver_merge_operation </td>
          <td>(</td>
          <td class="paramtype">globus_xio_operation_t&#160;</td>
          <td class="paramname"><em>top_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">globus_xio_operation_t&#160;</td>
          <td class="paramname"><em>bottom_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finishes an operation and merge two op structures. (XXX not implemented yet)</p>
<p>This function will join to operations together and signal globus_xio that it has completed. This is an advanced function. Most drivers will not require its use. This function takes an operation that was created by this driver and passed on to drivers lower on the stack and an operation that came in on the interface function (that has seen the top half of the stack) and joins them together. The purpose of this function is to join data descriptors that were pre-staged and cached with those that have later come in at the users request. See the read ahead doc for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">top_op</td><td>The operation that has seen the top part of the driver stack.</td></tr>
    <tr><td class="paramname">bottom_op</td><td>The operation that has seen the bottom part of the driver stack.</td></tr>
  </table>
  </dd>
</dl>
<p>(result is always success in this case. if there is an error, use the other finish() call) </p>

</div>
</div>
<a class="anchor" id="gadb6d86a1bcc3e26fa79409fff0c12fbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a> globus_xio_driver_operation_create </td>
          <td>(</td>
          <td class="paramtype">globus_xio_operation_t *&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">globus_xio_driver_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Driver API Create Operation</p>
<p>This function will create an operation from an initialized handle This operation can then be used for io operations related to the handle that created them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operation</td><td>The operation to be created. When this function returns this structure will be populated and available for use for the driver.</td></tr>
    <tr><td class="paramname">handle</td><td>The initialized handle representing the user handle from which the operation will be created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7a6ca96702627319debc6fb26ef91c3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__globus__common.html#gab407d5994daaaede9d66b8f1361180e2">globus_bool_t</a> globus_xio_driver_operation_is_blocking </td>
          <td>(</td>
          <td class="paramtype">globus_xio_operation_t&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Is Operation blocking.</p>
<p>If the operation is blocking the driver developer may be able to make certain optimizations. The function returns true if the given operation was created via a user call to a blocking function. </p>

</div>
</div>
<a class="anchor" id="ga1055f3fe75d618ec1b000e6abd0bcf6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a> globus_xio_driver_pass_close </td>
          <td>(</td>
          <td class="paramtype">globus_xio_operation_t&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__globus__xio__driver.html#ga3a9838db6dd3455d8cfcd8bbb27668fc">globus_xio_driver_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass the close operation down the driver stack. </p>
<p>This function will pass a close request down the driver stack. Upon completion of the close operation globus_xio will call the function pointed to by the cb parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The close operation. </td></tr>
    <tr><td class="paramname">cb</td><td>A pointer to the function to be called once all drivers lower in the stack have closed. </td></tr>
    <tr><td class="paramname">callback_arg</td><td>A pointer that will be passed to the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab05d3c532e2fceb2e901c8158ebed7b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a> globus_xio_driver_pass_open </td>
          <td>(</td>
          <td class="paramtype">globus_xio_operation_t&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const globus_xio_contact_t *&#160;</td>
          <td class="paramname"><em>contact_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__globus__xio__driver.html#ga3a9838db6dd3455d8cfcd8bbb27668fc">globus_xio_driver_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Driver API Open</p>
<p>This function will pass an open request down the driver stack. Upon completion of the open operation globus_xio will call the <em>cb</em> function, at which point the handle structure will be initialized and available for use.</p>
<p>As soon as the function returns the handle is valid for creating other operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation from which the handle will be established. This parameter is used to determine what drivers are in the stack and other such information.</td></tr>
    <tr><td class="paramname">contact_info</td><td>The contact info describing the resource the driver below should open. This will normally be the same contact info that was passed in on the open interface.</td></tr>
    <tr><td class="paramname">cb</td><td>The function to be called when the open operation is complete.</td></tr>
    <tr><td class="paramname">user_arg</td><td>a user pointer that will be threaded through to the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga58752308dec9897639cbb59a05660ead"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a> globus_xio_driver_pass_read </td>
          <td>(</td>
          <td class="paramtype">globus_xio_operation_t&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">globus_xio_iovec_t *&#160;</td>
          <td class="paramname"><em>iovec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovec_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__globus__common.html#gac9ab189b9de1c4adfacd6422598ce60f">globus_size_t</a>&#160;</td>
          <td class="paramname"><em>wait_for</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__globus__xio__driver.html#ga2a9093c9edcd0638236f8efc64edd5ab">globus_xio_driver_data_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Driver read</p>
<p>This function passes a read operation down the driver stack. After this function is called the op structure is no longer valid. However when the driver stack finishes servicing the read request it will pass a new operation structure in the function pointed to by cb. Finish read can be called on the new operation received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation structure representing this requested io operation.</td></tr>
    <tr><td class="paramname">iovec</td><td>A pointer to the array of iovecs.</td></tr>
    <tr><td class="paramname">iovec_count</td><td>The number of iovecs in the array.</td></tr>
    <tr><td class="paramname">wait_for</td><td>The minimum number of bytes to read before returning. if a driver has no specific requirement, he should use the user's request available via GlobusXIOOperationMinimumRead(op) </td></tr>
    <tr><td class="paramname">cb</td><td>The function to be called when the operation request is completed.</td></tr>
    <tr><td class="paramname">user_arg</td><td>A user pointer that will be threaded through to the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga188c0c7573ab8ce750931f13c320492c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a> globus_xio_driver_pass_write </td>
          <td>(</td>
          <td class="paramtype">globus_xio_operation_t&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">globus_xio_iovec_t *&#160;</td>
          <td class="paramname"><em>iovec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovec_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__globus__common.html#gac9ab189b9de1c4adfacd6422598ce60f">globus_size_t</a>&#160;</td>
          <td class="paramname"><em>wait_for</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__globus__xio__driver.html#ga2a9093c9edcd0638236f8efc64edd5ab">globus_xio_driver_data_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Driver write</p>
<p>This function passes a write operation down the driver stack. After this function is called the op structure is no longer valid. However when the driver stack finishes servicing the write request it will pass a new operation structure in the function pointed to by cb. Finished write can be called on the new operation received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation structure representing this requested io operation.</td></tr>
    <tr><td class="paramname">iovec</td><td>A pointer to the array of iovecs.</td></tr>
    <tr><td class="paramname">iovec_count</td><td>The number of iovecs in the array.</td></tr>
    <tr><td class="paramname">wait_for</td><td>The minimum number of bytes to write before returning. If a driver has no specific requirement, he should use the user's request available via GlobusXIOOperationMinimumWrite(op)</td></tr>
    <tr><td class="paramname">cb</td><td>The function to be called when the operation request is completed.</td></tr>
    <tr><td class="paramname">user_arg</td><td>A user pointer that will be threaded through to the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2e14d54eaea850252b6309167169fbcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void globus_xio_driver_set_eof_received </td>
          <td>(</td>
          <td class="paramtype">globus_xio_operation_t&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>EOF state manipulation</p>
<p>This function is used by drivers that allow multiple outstanding reads at a time. It can only be called on behalf of a read operation (while in the read interface call or the pass_read callback).</p>
<p>Typical use for this would be to hold a driver specific lock and call this when an internal EOF has been received. The read operation this is called on behalf of must be finished with an EOF error or the results are undefined.</p>
<p>In general, you should not have an EOF flag in your driver. Use this call and <a class="el" href="group__globus__xio__driver.html#ga709c597e1f6d8bd9b81721d210e59bc0">globus_xio_driver_eof_received()</a> instead. This is necessary to support XIO's automatic EOF resetting. If your driver absolutely can not be read after an EOF has been set, then you will need your own EOF flag.</p>
<p>This call will typically only be used just before a finished_read() call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation structure representing the requested read operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa0c5bca7682aa876c1a2dde31251f371"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__globus__common.html#gab3aa7be121bcab5daf208d5d99b4e8f2">globus_result_t</a> globus_xio_driver_set_server_pre_init </td>
          <td>(</td>
          <td class="paramtype">globus_xio_driver_t&#160;</td>
          <td class="paramname"><em>driver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__globus__xio__driver.html#ga83aab000e4bc988243e7c8757ed756e7">globus_xio_driver_server_init_t</a>&#160;</td>
          <td class="paramname"><em>server_pre_init_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Server Pre-Init. </p>
<p>This function adds a callback to a driver that will be called before a server handle is created by XIO. This function has the same signature as the server_init_func in the driver, but is always called with a NULL contact string. There is no support for calling a pass() or finished() function for this interface. It may inspect and modify its attributes and operation, but can not directly return any data or set a driver-specific server handle value. If this function returns an error result, the server create will be aborted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">driver</td><td>Driver to associate the function with </td></tr>
    <tr><td class="paramname">server_pre_init_func</td><td>Function to call prior to creating a server </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">GLOBUS_SUCCESS</td><td>Success </td></tr>
    <tr><td class="paramname">GLOBUS_XIO_ERROR_PARAMETER</td><td>Invalid parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
