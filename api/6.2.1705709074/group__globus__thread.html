<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Grid Community Toolkit: Threading</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Grid Community Toolkit
   &#160;<span id="projectnumber">6.2.1705709074 (tag: v6.2.20240202)</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Threading<div class="ingroups"><a class="el" href="group__globus__common.html">Globus Common API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Portable Thread Abstraction.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__globus__mutex"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__mutex.html">Mutual Exclusion</a></td></tr>
<tr class="memdesc:group__globus__mutex"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutual Exclusion. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__globus__cond"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__cond.html">Condition Variables</a></td></tr>
<tr class="memdesc:group__globus__cond"><td class="mdescLeft">&#160;</td><td class="mdescRight">Condition Variables. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__globus__thread__key"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__thread__key.html">Thread-Specific Storage</a></td></tr>
<tr class="memdesc:group__globus__thread__key"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-Specific Storage. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__globus__thread__once"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__thread__once.html">One-time execution</a></td></tr>
<tr class="memdesc:group__globus__thread__once"><td class="mdescLeft">&#160;</td><td class="mdescRight">One-time execution. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionglobus__thread__t.html">globus_thread_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread ID.  <a href="unionglobus__thread__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionglobus__threadattr__t.html">globus_threadattr_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread attributes.  <a href="unionglobus__threadattr__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionglobus__thread__key__t.html">globus_thread_key_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-specific data key.  <a href="unionglobus__thread__key__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaf15a5fb8ed82c9a48bf3315bfe1142c9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__thread.html#gaf15a5fb8ed82c9a48bf3315bfe1142c9">GLOBUS_THREAD_CANCEL_DISABLE</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gaf15a5fb8ed82c9a48bf3315bfe1142c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable thread cancellation value.  <a href="#gaf15a5fb8ed82c9a48bf3315bfe1142c9">More...</a><br/></td></tr>
<tr class="separator:gaf15a5fb8ed82c9a48bf3315bfe1142c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54aa25c95e89566ba181eea9733651d0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__thread.html#ga54aa25c95e89566ba181eea9733651d0">GLOBUS_THREAD_CANCEL_ENABLE</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga54aa25c95e89566ba181eea9733651d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable thread cancellation value.  <a href="#ga54aa25c95e89566ba181eea9733651d0">More...</a><br/></td></tr>
<tr class="separator:ga54aa25c95e89566ba181eea9733651d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e4ac32bb0133044557d82ae454c5524"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1e4ac32bb0133044557d82ae454c5524"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__thread.html#ga1e4ac32bb0133044557d82ae454c5524">GLOBUS_THREAD_MODULE</a>&#160;&#160;&#160;(&amp;globus_i_thread_module)</td></tr>
<tr class="memdesc:ga1e4ac32bb0133044557d82ae454c5524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread Module. <br/></td></tr>
<tr class="separator:ga1e4ac32bb0133044557d82ae454c5524"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gab9a4db7600579bd5aad4383fa57551d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab9a4db7600579bd5aad4383fa57551d9"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__thread.html#gab9a4db7600579bd5aad4383fa57551d9">globus_thread_key_destructor_func_t</a> )(void *value)</td></tr>
<tr class="memdesc:gab9a4db7600579bd5aad4383fa57551d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-specific data destructor. <br/></td></tr>
<tr class="separator:gab9a4db7600579bd5aad4383fa57551d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab1e6b22b1d55346b3191402fdc7e341b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__thread.html#gab1e6b22b1d55346b3191402fdc7e341b">globus_thread_set_model</a> (const char *model)</td></tr>
<tr class="memdesc:gab1e6b22b1d55346b3191402fdc7e341b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select threading model for an application.  <a href="#gab1e6b22b1d55346b3191402fdc7e341b">More...</a><br/></td></tr>
<tr class="separator:gab1e6b22b1d55346b3191402fdc7e341b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac743f4cd1e4a49e6ccc23dea8d8a1775"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__thread.html#gac743f4cd1e4a49e6ccc23dea8d8a1775">globus_thread_create</a> (<a class="el" href="unionglobus__thread__t.html">globus_thread_t</a> *thread, <a class="el" href="unionglobus__threadattr__t.html">globus_threadattr_t</a> *attr, globus_thread_func_t func, void *user_arg)</td></tr>
<tr class="memdesc:gac743f4cd1e4a49e6ccc23dea8d8a1775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new thread.  <a href="#gac743f4cd1e4a49e6ccc23dea8d8a1775">More...</a><br/></td></tr>
<tr class="separator:gac743f4cd1e4a49e6ccc23dea8d8a1775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a6e15c71b17287216b6503861386d37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__thread.html#ga6a6e15c71b17287216b6503861386d37">globus_thread_yield</a> (void)</td></tr>
<tr class="memdesc:ga6a6e15c71b17287216b6503861386d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield execution to another thread.  <a href="#ga6a6e15c71b17287216b6503861386d37">More...</a><br/></td></tr>
<tr class="separator:ga6a6e15c71b17287216b6503861386d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad82ec7a9a046558859124766c85e8491"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__thread.html#gad82ec7a9a046558859124766c85e8491">globus_thread_exit</a> (void *value)</td></tr>
<tr class="memdesc:gad82ec7a9a046558859124766c85e8491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminate the current thread.  <a href="#gad82ec7a9a046558859124766c85e8491">More...</a><br/></td></tr>
<tr class="separator:gad82ec7a9a046558859124766c85e8491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf6ddab884b07297c0699e9793aa8726"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__thread.html#gadf6ddab884b07297c0699e9793aa8726">globus_thread_sigmask</a> (int how, const sigset_t *new_mask, sigset_t *old_mask)</td></tr>
<tr class="memdesc:gadf6ddab884b07297c0699e9793aa8726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the current thread's signal mask.  <a href="#gadf6ddab884b07297c0699e9793aa8726">More...</a><br/></td></tr>
<tr class="separator:gadf6ddab884b07297c0699e9793aa8726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae606e850d19fd3fe438fa6bfc6515394"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__thread.html#gae606e850d19fd3fe438fa6bfc6515394">globus_thread_kill</a> (<a class="el" href="unionglobus__thread__t.html">globus_thread_t</a> thread, int sig)</td></tr>
<tr class="memdesc:gae606e850d19fd3fe438fa6bfc6515394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a signal to a thread.  <a href="#gae606e850d19fd3fe438fa6bfc6515394">More...</a><br/></td></tr>
<tr class="separator:gae606e850d19fd3fe438fa6bfc6515394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0075f9c3c3c1e2a2eb41a10913ccfca6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="unionglobus__thread__t.html">globus_thread_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__thread.html#ga0075f9c3c3c1e2a2eb41a10913ccfca6">globus_thread_self</a> (void)</td></tr>
<tr class="memdesc:ga0075f9c3c3c1e2a2eb41a10913ccfca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the current thread's ID.  <a href="#ga0075f9c3c3c1e2a2eb41a10913ccfca6">More...</a><br/></td></tr>
<tr class="separator:ga0075f9c3c3c1e2a2eb41a10913ccfca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0858d6945cc5ed82cec65eadd2ef0a32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__globus__common.html#gab407d5994daaaede9d66b8f1361180e2">globus_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__thread.html#ga0858d6945cc5ed82cec65eadd2ef0a32">globus_thread_equal</a> (<a class="el" href="unionglobus__thread__t.html">globus_thread_t</a> thread1, <a class="el" href="unionglobus__thread__t.html">globus_thread_t</a> thread2)</td></tr>
<tr class="memdesc:ga0858d6945cc5ed82cec65eadd2ef0a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether thread identifiers match.  <a href="#ga0858d6945cc5ed82cec65eadd2ef0a32">More...</a><br/></td></tr>
<tr class="separator:ga0858d6945cc5ed82cec65eadd2ef0a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga138729b018e3e31bd591d9421af656f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__globus__common.html#gab407d5994daaaede9d66b8f1361180e2">globus_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__thread.html#ga138729b018e3e31bd591d9421af656f7">globus_thread_preemptive_threads</a> (void)</td></tr>
<tr class="memdesc:ga138729b018e3e31bd591d9421af656f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate whether the active thread model supports preemption.  <a href="#ga138729b018e3e31bd591d9421af656f7">More...</a><br/></td></tr>
<tr class="separator:ga138729b018e3e31bd591d9421af656f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8df3fff10bd599db534519b6907e1922"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__globus__common.html#gab407d5994daaaede9d66b8f1361180e2">globus_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__thread.html#ga8df3fff10bd599db534519b6907e1922">globus_i_am_only_thread</a> (void)</td></tr>
<tr class="memdesc:ga8df3fff10bd599db534519b6907e1922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if threads are supported.  <a href="#ga8df3fff10bd599db534519b6907e1922">More...</a><br/></td></tr>
<tr class="separator:ga8df3fff10bd599db534519b6907e1922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga990a7deb9ec83c5bf4ca8a25d1fdc3a0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__thread.html#ga990a7deb9ec83c5bf4ca8a25d1fdc3a0">globus_thread_cancellable_func</a> (void *(*func)(void *), void *arg, void(*cleanup_func)(void *), void *cleanup_arg, <a class="el" href="group__globus__common.html#gab407d5994daaaede9d66b8f1361180e2">globus_bool_t</a> execute_cleanup)</td></tr>
<tr class="memdesc:ga990a7deb9ec83c5bf4ca8a25d1fdc3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a function with thread cleanup in case of cancellation.  <a href="#ga990a7deb9ec83c5bf4ca8a25d1fdc3a0">More...</a><br/></td></tr>
<tr class="separator:ga990a7deb9ec83c5bf4ca8a25d1fdc3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aca327a5a9ed473446a788f255e793f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__thread.html#ga3aca327a5a9ed473446a788f255e793f">globus_thread_cancel</a> (<a class="el" href="unionglobus__thread__t.html">globus_thread_t</a> thr)</td></tr>
<tr class="memdesc:ga3aca327a5a9ed473446a788f255e793f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a thread.  <a href="#ga3aca327a5a9ed473446a788f255e793f">More...</a><br/></td></tr>
<tr class="separator:ga3aca327a5a9ed473446a788f255e793f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0397b4b91b07b45d27f30ba5954bc7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__thread.html#gae0397b4b91b07b45d27f30ba5954bc7c">globus_thread_testcancel</a> (void)</td></tr>
<tr class="memdesc:gae0397b4b91b07b45d27f30ba5954bc7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread cancellation point.  <a href="#gae0397b4b91b07b45d27f30ba5954bc7c">More...</a><br/></td></tr>
<tr class="separator:gae0397b4b91b07b45d27f30ba5954bc7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga201f97630ba96e417c65a9ffe4075e6c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__globus__thread.html#ga201f97630ba96e417c65a9ffe4075e6c">globus_thread_setcancelstate</a> (int state, int *oldstate)</td></tr>
<tr class="memdesc:ga201f97630ba96e417c65a9ffe4075e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the thread's cancellable state.  <a href="#ga201f97630ba96e417c65a9ffe4075e6c">More...</a><br/></td></tr>
<tr class="separator:ga201f97630ba96e417c65a9ffe4075e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Portable Thread Abstraction. </p>
<p>The Globus runtime includes support for portably creating threads on POSIX and Windows systems. It also provides a callback-driven system for applications that may use threads but don't require them. The Globus Thread API is modeled closely after the POSIX threads API.</p>
<p>Applications can choose whether to run as threaded or non-threaded at runtime by either setting the GLOBUS_THREAD_MODEL environment variable or calling the <a class="el" href="group__globus__thread.html#gab1e6b22b1d55346b3191402fdc7e341b" title="Select threading model for an application. ">globus_thread_set_model()</a> function prior to activating any Globus modules.</p>
<p>The Globus thread system provides primitives for mutual exclusion (<a class="el" href="unionglobus__mutex__t.html" title="Mutex. ">globus_mutex_t</a>, <a class="el" href="structglobus__rmutex__t.html" title="Recursive Mutex. ">globus_rmutex_t</a>, globus_rw_mutex_t), event synchronization (<a class="el" href="unionglobus__cond__t.html" title="Condition variable. ">globus_cond_t</a>), one-time execution (globus_once_t), and threading (<a class="el" href="unionglobus__thread__t.html" title="Thread ID. ">globus_thread_t</a>).</p>
<p>In non-threaded operation, <a class="el" href="group__globus__cond.html#ga9b58106e5b1b2545ab45db0e3e4f98b0" title="Wait for a condition to be signalled. ">globus_cond_wait()</a> and its variants will poll the callback queue and I/O system to allow event-driven programs to run in the absence of threads. The <a class="el" href="group__globus__thread.html#gac743f4cd1e4a49e6ccc23dea8d8a1775" title="Create a new thread. ">globus_thread_create()</a> function will fail in that model. Other primitive operations will return success but not provide any thread exclusion as there is only one thread. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gaf15a5fb8ed82c9a48bf3315bfe1142c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GLOBUS_THREAD_CANCEL_DISABLE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable thread cancellation value. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__globus__thread.html#ga201f97630ba96e417c65a9ffe4075e6c" title="Set the thread&#39;s cancellable state. ">globus_thread_setcancelstate()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga54aa25c95e89566ba181eea9733651d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GLOBUS_THREAD_CANCEL_ENABLE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable thread cancellation value. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__globus__thread.html#ga201f97630ba96e417c65a9ffe4075e6c" title="Set the thread&#39;s cancellable state. ">globus_thread_setcancelstate()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga8df3fff10bd599db534519b6907e1922"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__globus__common.html#gab407d5994daaaede9d66b8f1361180e2">globus_bool_t</a> globus_i_am_only_thread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if threads are supported. </p>
<p>The <a class="el" href="group__globus__thread.html#ga8df3fff10bd599db534519b6907e1922" title="Determine if threads are supported. ">globus_i_am_only_thread()</a> function determines whether multiple threads may be running in this process. </p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__globus__thread.html#ga8df3fff10bd599db534519b6907e1922" title="Determine if threads are supported. ">globus_i_am_only_thread()</a> function returns GLOBUS_TRUE if the current thread model is the "none" thread model; GLOBUS_FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3aca327a5a9ed473446a788f255e793f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int globus_thread_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionglobus__thread__t.html">globus_thread_t</a>&#160;</td>
          <td class="paramname"><em>thr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel a thread. </p>
<p>The <a class="el" href="group__globus__thread.html#ga3aca327a5a9ed473446a788f255e793f" title="Cancel a thread. ">globus_thread_cancel()</a> function cancels the thread with the identifier <em>thr</em> if it is still executing. If it is running with a cancellation cleanup stack, the functions in that stack are executed. The target thread's cancel state determines when the cancellation is delivered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>The id of the thread to cancel</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the <a class="el" href="group__globus__thread.html#ga3aca327a5a9ed473446a788f255e793f" title="Cancel a thread. ">globus_thread_cancel()</a> function delivers the cancellation to the target thread and returns GLOBUS_SUCCESS. If an error occurs, <a class="el" href="group__globus__thread.html#ga3aca327a5a9ed473446a788f255e793f" title="Cancel a thread. ">globus_thread_cancel()</a> returns an implementation-specific non-zero error value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga990a7deb9ec83c5bf4ca8a25d1fdc3a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* globus_thread_cancellable_func </td>
          <td>(</td>
          <td class="paramtype">void *(*)(void *)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>cleanup_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cleanup_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__globus__common.html#gab407d5994daaaede9d66b8f1361180e2">globus_bool_t</a>&#160;</td>
          <td class="paramname"><em>execute_cleanup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a function with thread cleanup in case of cancellation. </p>
<p>The <a class="el" href="group__globus__thread.html#ga990a7deb9ec83c5bf4ca8a25d1fdc3a0" title="Execute a function with thread cleanup in case of cancellation. ">globus_thread_cancellable_func()</a> function provides an interface to POSIX thread cancellation points that does not rely on preprocessor macros. It is roughly equivalent to </p>
<div class="fragment"><div class="line">pthread_cleanup_push(cleanup_func, cleanup_arg);</div>
<div class="line">(*func)(arg);</div>
<div class="line">pthread_cleanup_pop(execute_cleanup)</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Pointer to a function which may be cancelled. </td></tr>
    <tr><td class="paramname">arg</td><td>Parameter to the <em>func</em> function. </td></tr>
    <tr><td class="paramname">cleanup_func</td><td>Pointer to a function to execute if thread cancellation occurs during <em>func</em>. </td></tr>
    <tr><td class="paramname">cleanup_arg</td><td>Parameter to the <em>cleanup_func</em> function. </td></tr>
    <tr><td class="paramname">execute_cleanup</td><td>Flag indicating whether the function pointed to by <em>cleanup_func</em> should be executed after <em>func</em> completes even if it is not cancelled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__globus__thread.html#ga990a7deb9ec83c5bf4ca8a25d1fdc3a0" title="Execute a function with thread cleanup in case of cancellation. ">globus_thread_cancellable_func()</a> returns the value returned by <em>func</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="gac743f4cd1e4a49e6ccc23dea8d8a1775"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int globus_thread_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionglobus__thread__t.html">globus_thread_t</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionglobus__threadattr__t.html">globus_threadattr_t</a> *&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">globus_thread_func_t&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new thread. </p>
<p>The <a class="el" href="group__globus__thread.html#gac743f4cd1e4a49e6ccc23dea8d8a1775" title="Create a new thread. ">globus_thread_create()</a> function creates a new thread of execution in the current process to run the function pointed to by the <em>func</em> parameter passed the <em>user_arg</em> value as its only parameter. This new thread will be detached, so that storage associated with the thread will be automatically reclaimed by the operating system. A thread identifier will be copied to the value pointed by the <em>thread</em> parameter if it is non-NULL. The caller may use this thread identifier to signal or cancel this thread. The <em>attr</em> parameter is ignored by this function. If the "none" threading model is used by an application, then this function will always fail. One alternative that will work both with and without threads is to use the functions in the <a class="el" href="group__globus__callback.html">Globus Callback API </a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Pointer to a variable to contain the new thread's identifier. </td></tr>
    <tr><td class="paramname">attr</td><td>Ignored </td></tr>
    <tr><td class="paramname">func</td><td>Pointer to a function to start in the new thread. </td></tr>
    <tr><td class="paramname">user_arg</td><td>Argument to the new thread's function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, <a class="el" href="group__globus__thread.html#gac743f4cd1e4a49e6ccc23dea8d8a1775" title="Create a new thread. ">globus_thread_create()</a> will start a new thread, invoking (*func)(user_arg), modify the value pointed to by the <em>thread</em> parameter to contain the new thread's identifier and return GLOBUS_SUCCESS. If an error occurs, then the value of <em>thread</em> is undefined and <a class="el" href="group__globus__thread.html#gac743f4cd1e4a49e6ccc23dea8d8a1775" title="Create a new thread. ">globus_thread_create()</a> returns an implementation-specific non-zero error value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0858d6945cc5ed82cec65eadd2ef0a32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__globus__common.html#gab407d5994daaaede9d66b8f1361180e2">globus_bool_t</a> globus_thread_equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionglobus__thread__t.html">globus_thread_t</a>&#160;</td>
          <td class="paramname"><em>thread1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionglobus__thread__t.html">globus_thread_t</a>&#160;</td>
          <td class="paramname"><em>thread2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether thread identifiers match. </p>
<p>The <a class="el" href="group__globus__thread.html#ga0858d6945cc5ed82cec65eadd2ef0a32" title="Check whether thread identifiers match. ">globus_thread_equal()</a> function checks whether the thread identifiers passed as the <em>thread1</em> and <em>thread2</em> parameters refer to the same thread. If so, <a class="el" href="group__globus__thread.html#ga0858d6945cc5ed82cec65eadd2ef0a32" title="Check whether thread identifiers match. ">globus_thread_equal()</a> returns GLOBUS_TRUE; otherwise GLOBUS_FALSE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread1</td><td>Thread identifier to compare. </td></tr>
    <tr><td class="paramname">thread2</td><td>Thread identifier to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">GLOBUS_TRUE</td><td>thread1 and thread2 refer to the same thread. </td></tr>
    <tr><td class="paramname">GLOBUS_FALSE</td><td>thread1 and thread2 do not refer to the same thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad82ec7a9a046558859124766c85e8491"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void globus_thread_exit </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminate the current thread. </p>
<p>The <a class="el" href="group__globus__thread.html#gad82ec7a9a046558859124766c85e8491" title="Terminate the current thread. ">globus_thread_exit()</a> terminates the current thread with the value passed to it. This function does not return. </p>

</div>
</div>
<a class="anchor" id="gae606e850d19fd3fe438fa6bfc6515394"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int globus_thread_kill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionglobus__thread__t.html">globus_thread_t</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a signal to a thread. </p>
<p>The <a class="el" href="group__globus__thread.html#gae606e850d19fd3fe438fa6bfc6515394" title="Send a signal to a thread. ">globus_thread_kill()</a> function sends the signal specified by the <em>sig</em> number to the thread whose ID matches the <em>thread</em> parameter. Depending on the signal mask of that thread, this may result in a signal being delivered or not, and depending on the process's signal actions, a signal handler, termination, or no operation will occur in that thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread identifier of the thread to signal. </td></tr>
    <tr><td class="paramname">sig</td><td>The signal to send to the thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, <a class="el" href="group__globus__thread.html#gae606e850d19fd3fe438fa6bfc6515394" title="Send a signal to a thread. ">globus_thread_kill()</a> queues the signal for delivery to the specified thread and returns GLOBUS_SUCCESS. If an error occurs, <a class="el" href="group__globus__thread.html#gae606e850d19fd3fe438fa6bfc6515394" title="Send a signal to a thread. ">globus_thread_kill()</a> returns an implementation-specific non-zero error value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga138729b018e3e31bd591d9421af656f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__globus__common.html#gab407d5994daaaede9d66b8f1361180e2">globus_bool_t</a> globus_thread_preemptive_threads </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate whether the active thread model supports preemption. </p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__globus__thread.html#ga138729b018e3e31bd591d9421af656f7" title="Indicate whether the active thread model supports preemption. ">globus_thread_preemptive_threads()</a> function returns GLOBUS_TRUE if the current thread model supports thread preemption; otherwise it returns GLOBUS_FALSE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0075f9c3c3c1e2a2eb41a10913ccfca6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unionglobus__thread__t.html">globus_thread_t</a> globus_thread_self </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the current thread's ID. </p>
<p>The <a class="el" href="group__globus__thread.html#ga0075f9c3c3c1e2a2eb41a10913ccfca6" title="Determine the current thread&#39;s ID. ">globus_thread_self()</a> function returns the thread identifier of the current thread. This value is unique among all threads which are running at any given time. </p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__globus__thread.html#ga0075f9c3c3c1e2a2eb41a10913ccfca6" title="Determine the current thread&#39;s ID. ">globus_thread_self()</a> function returns the current thread's ID. </dd></dl>

</div>
</div>
<a class="anchor" id="gab1e6b22b1d55346b3191402fdc7e341b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int globus_thread_set_model </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select threading model for an application. </p>
<p>The <a class="el" href="group__globus__thread.html#gab1e6b22b1d55346b3191402fdc7e341b" title="Select threading model for an application. ">globus_thread_set_model()</a> function selects which runtime model the current application will use. By default, the Globus runtime uses a non-threaded model. Additional models may be available based on system support: pthread, or windows. This function must be called prior to activating any globus module, as it changes how certain functions (like <a class="el" href="group__globus__mutex.html#ga053b5f9b263f11b7305efdbee881bf5d" title="Lock a mutex. ">globus_mutex_lock()</a> and <a class="el" href="group__globus__cond.html#ga9b58106e5b1b2545ab45db0e3e4f98b0" title="Wait for a condition to be signalled. ">globus_cond_wait()</a>) behave. This function overrides the value set by the GLOBUS_THREAD_MODEL environment variable.</p>
<p>The <a class="el" href="group__globus__thread.html#gab1e6b22b1d55346b3191402fdc7e341b" title="Select threading model for an application. ">globus_thread_set_model()</a> function will fail if a Globus module has been activated already.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The name of the thread model to use. Depending on operating system capabilities, this may be "none", "pthread", "windows", or some other custom thread implementation. The corresponding libtool module "libglobus_thread_pthread.la" or "libglobus_thread_windows.la" must be installed on the system for it to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, <a class="el" href="group__globus__thread.html#gab1e6b22b1d55346b3191402fdc7e341b" title="Select threading model for an application. ">globus_thread_set_model()</a> sets the name of the thread model to use and returns GLOBUS_SUCCESS. If an error occurs, then <a class="el" href="group__globus__thread.html#gab1e6b22b1d55346b3191402fdc7e341b" title="Select threading model for an application. ">globus_thread_set_model()</a> returns GLOBUS_FAILURE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga201f97630ba96e417c65a9ffe4075e6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int globus_thread_setcancelstate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>oldstate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the thread's cancellable state. </p>
<p>The <a class="el" href="group__globus__thread.html#ga201f97630ba96e417c65a9ffe4075e6c" title="Set the thread&#39;s cancellable state. ">globus_thread_setcancelstate()</a> function sets the current cancellation state to either GLOBUS_THREAD_CANCEL_DISABLE or GLOBUS_THREAD_CANCEL_ENABLE, do control whether <a class="el" href="group__globus__thread.html#ga3aca327a5a9ed473446a788f255e793f" title="Cancel a thread. ">globus_thread_cancel()</a> is able to cancel this thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The desired cancellation state. If the value is GLOBUS_THREAD_CANCEL_DISABLE, then cancellation will be disabled for this thread. If the value is GLOBUS_THREAD_CANCEL_ENABLE, then cancellation will be enabled for this thread. </td></tr>
    <tr><td class="paramname">oldstate</td><td>A pointer to a value which will be set to the value of the thread's cancellation state when this function call began. This may be NULL if the caller is not interested in the previous value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the <a class="el" href="group__globus__thread.html#ga201f97630ba96e417c65a9ffe4075e6c" title="Set the thread&#39;s cancellable state. ">globus_thread_setcancelstate()</a> function modifies the thread cancellation state, modifies oldstate (if non-NULL) to the value of its previous state, and returns GLOBUS_SUCCESS. If an error occurs, <a class="el" href="group__globus__thread.html#ga201f97630ba96e417c65a9ffe4075e6c" title="Set the thread&#39;s cancellable state. ">globus_thread_setcancelstate()</a> returns an implementation-specific non-zero error value. </dd></dl>

</div>
</div>
<a class="anchor" id="gadf6ddab884b07297c0699e9793aa8726"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int globus_thread_sigmask </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>how</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sigset_t *&#160;</td>
          <td class="paramname"><em>new_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigset_t *&#160;</td>
          <td class="paramname"><em>old_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify the current thread's signal mask. </p>
<p>The <a class="el" href="group__globus__thread.html#gadf6ddab884b07297c0699e9793aa8726" title="Modify the current thread&#39;s signal mask. ">globus_thread_sigmask()</a> function modifies the current thread's signal mask and returns the old value of the signal mask in the value pointed to by the <em>old_mask</em> parameter. The <em>how</em> parameter can be one of SIG_BLOCK, SIG_UNBLOCK, or SIG_SETMASK to control how the signal mask is modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">how</td><td>Flag indicating how to interpret <em>new_mask</em> if it is non-NULL. If <em>how</em> is SIG_BLOCK, then all signals in <em>new_mask</em> are blocked, as well as any which were previously blocked. If <em>how</em> is SIG_UNBLOCK, then all signals in which were previously blocked in <em>new_mask</em> are unblocked. If <em>how</em> is SIG_SETMASK, then the old signal mask is replaced with the value of <em>new_mask</em>. </td></tr>
    <tr><td class="paramname">new_mask</td><td>Set of signals to block or unblock, based on the <em>how</em> parameter. </td></tr>
    <tr><td class="paramname">old_mask</td><td>A pointer to be set to the old signal mask associated with the current thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, <a class="el" href="group__globus__thread.html#gadf6ddab884b07297c0699e9793aa8726" title="Modify the current thread&#39;s signal mask. ">globus_thread_sigmask()</a> modifies the signal mask, modifies the value pointed to by <em>old_mask</em> with the signal mask prior to this function's execution and returns GLOBUS_SUCCESS. If an error occurs, <a class="el" href="group__globus__thread.html#gadf6ddab884b07297c0699e9793aa8726" title="Modify the current thread&#39;s signal mask. ">globus_thread_sigmask()</a> returns an implementation-specific non-zero error value. </dd></dl>

</div>
</div>
<a class="anchor" id="gae0397b4b91b07b45d27f30ba5954bc7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void globus_thread_testcancel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread cancellation point. </p>
<p>The <a class="el" href="group__globus__thread.html#gae0397b4b91b07b45d27f30ba5954bc7c" title="Thread cancellation point. ">globus_thread_testcancel()</a> function acts as a cancellation point for the current thread. If a thread has called <a class="el" href="group__globus__thread.html#ga3aca327a5a9ed473446a788f255e793f" title="Cancel a thread. ">globus_thread_cancel()</a> and cancellation is enabled, this will cause the thread to be cancelled and any functions on the thread's cleanup stack to be executed. This function will not return if the thread is cancelled. </p>

</div>
</div>
<a class="anchor" id="ga6a6e15c71b17287216b6503861386d37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void globus_thread_yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield execution to another thread. </p>
<p>The <a class="el" href="group__globus__thread.html#ga6a6e15c71b17287216b6503861386d37" title="Yield execution to another thread. ">globus_thread_yield()</a> function yields execution to other threads which are ready for execution. The current thread may continue to execute if there are no other threads in the system's ready queue. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
